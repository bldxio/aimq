{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AIMQ Documentation","text":"<p>AIMQ (AI Message Queue) is a Python library designed to simplify working with Supabase's queue system, which is built on top of pgmq. It provides an elegant way to process queued jobs using LangChain Runnables, making it perfect for AI-powered task processing and background job handling.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple Task Definition: Define queue processors using the <code>@worker.task</code> decorator to transform functions into LangChain RunnableLambda processors</li> <li>Supabase Integration: Built on Supabase's queue system (pgmq) for reliable and scalable message queuing</li> <li>LangChain Compatibility: Native support for LangChain Runnables, making it easy to integrate AI workflows</li> <li>Type Safety: Full type hints and runtime validation using Pydantic</li> <li>Flexible Job Processing: Support for delayed jobs, job timeouts, and customizable job completion handling</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Enable Supabase Queue Integration:</li> <li>In your Supabase project, enable the Queue integration</li> <li>Make sure \"Expose Queues via PostgREST\" is turned on</li> <li> <p>Create your queues through the Supabase interface</p> </li> <li> <p>Configure Environment:    <pre><code>SUPABASE_URL=your-project-url\nSUPABASE_KEY=your-service-role-key\n</code></pre></p> </li> <li> <p>Create Tasks:    <pre><code>from aimq import Worker\n\nworker = Worker()\n\n@worker.task(queue=\"process_text\")\ndef process_text(job_data):\n    # Process job_data using LangChain\n    return {\"result\": \"processed\"}\n\nworker.start()\n</code></pre></p> </li> </ol>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>Quick Start Guide</li> <li>API Reference</li> <li>Contributing Guide</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>AIMQ is currently in beta. While it is being used in production environments, the API may still undergo changes as we gather feedback from users.</p>"},{"location":"#license","title":"License","text":"<p>AIMQ is released under the MIT License. See the LICENSE file for more details.</p>"},{"location":"api/overview/","title":"API Reference","text":"<p>This section provides detailed documentation for AIMQ's API.</p>"},{"location":"api/overview/#core-components","title":"Core Components","text":""},{"location":"api/overview/#worker","title":"Worker","text":"<p>The <code>Worker</code> class is the main entry point for AIMQ. It manages queues and processes jobs:</p> <pre><code>from aimq import Worker\n\nworker = Worker()\n\n@worker.task(queue=\"my_queue\")\ndef process_data(data):\n    # Process data here\n    return {\"status\": \"processed\"}\n</code></pre>"},{"location":"api/overview/#queue","title":"Queue","text":"<p>The <code>Queue</code> class handles message queue operations:</p> <pre><code>from aimq import Queue\n\nqueue = Queue(\"my_queue\")\nqueue.send({\"data\": \"to process\"})\n</code></pre>"},{"location":"api/overview/#job","title":"Job","text":"<p>The <code>Job</code> class represents a unit of work:</p> <pre><code>from aimq import Job\n\n# Jobs are usually created from queue messages\njob = Job.from_response(response_data)\nprint(f\"Processing job {job.id}\")\n</code></pre>"},{"location":"api/overview/#tools","title":"Tools","text":"<p>AIMQ provides several built-in tools for document processing:</p>"},{"location":"api/overview/#ocr-tools","title":"OCR Tools","text":"<ul> <li>Image OCR: Extract text from images</li> <li>PDF Processor: Process PDF documents</li> </ul>"},{"location":"api/overview/#storage-tools","title":"Storage Tools","text":""},{"location":"api/overview/#supabase-storage","title":"Supabase Storage","text":"<ul> <li>Read and write files to Supabase Storage</li> <li>Manage file metadata and access control</li> </ul>"},{"location":"api/overview/#supabase-database","title":"Supabase Database","text":"<ul> <li>Read and write records to Supabase Database</li> <li>Manage database records and relationships</li> </ul>"},{"location":"api/overview/#error-handling","title":"Error Handling","text":"<p>AIMQ provides several exception classes for error handling:</p> <p>```python from aimq.exceptions import QueueError, ProcessingError</p> <p>try:     result = queue.work() except QueueError as e:     print(f\"Queue error: {e}\") except ProcessingError as e:     print(f\"Processing error: {e}\")</p>"},{"location":"api/tools/","title":"Tools API Reference","text":"<p>AIMQ provides a set of built-in tools for document processing and storage operations.</p>"},{"location":"api/tools/#ocr-tools","title":"OCR Tools","text":""},{"location":"api/tools/#image-ocr-image-ocr","title":"Image OCR {#image-ocr}","text":""},{"location":"api/tools/#aimq.tools.ocr.image_ocr","title":"<code>aimq.tools.ocr.image_ocr</code>","text":"<p>Tool for performing OCR on images.</p>"},{"location":"api/tools/#aimq.tools.ocr.image_ocr-classes","title":"Classes","text":""},{"location":"api/tools/#aimq.tools.ocr.image_ocr.ImageOCR","title":"<code>ImageOCR(**kwargs)</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for performing OCR on images.</p> <p>Initialize the OCR processor.</p> Source code in <code>src/aimq/tools/ocr/image_ocr.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the OCR processor.\"\"\"\n    super().__init__(**kwargs)\n    self.processor = OCRProcessor()\n</code></pre>"},{"location":"api/tools/#aimq.tools.ocr.image_ocr.ImageOCR-functions","title":"Functions","text":""},{"location":"api/tools/#aimq.tools.ocr.image_ocr.ImageOCRInput","title":"<code>ImageOCRInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for ImageOCR.</p>"},{"location":"api/tools/#pdf-processor-pdf-processor","title":"PDF Processor {#pdf-processor}","text":""},{"location":"api/tools/#aimq.tools.ocr.processor","title":"<code>aimq.tools.ocr.processor</code>","text":"<p>OCR module for text extraction and processing from images.</p> <p>This module provides functionality for extracting and processing text from images using the EasyOCR library. It includes utilities for handling text bounding boxes, merging overlapping detections, and creating debug visualizations.</p>"},{"location":"api/tools/#aimq.tools.ocr.processor-classes","title":"Classes","text":""},{"location":"api/tools/#aimq.tools.ocr.processor.OCRProcessor","title":"<code>OCRProcessor(languages=None)</code>","text":"<p>Processor for performing OCR on images using EasyOCR.</p> <p>This class provides a high-level interface for performing OCR on images. It handles initialization of the EasyOCR reader, image preprocessing, text detection, and optional debug visualization.</p> <p>Attributes:</p> Name Type Description <code>languages</code> <p>List of language codes for OCR</p> <code>_reader</code> <p>Lazy-loaded EasyOCR reader instance</p> <p>Initialize OCR processor with specified languages.</p> <p>Parameters:</p> Name Type Description Default <code>languages</code> <code>Optional[List[str]]</code> <p>List of language codes (default: ['en'])</p> <code>None</code> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def __init__(self, languages: Optional[List[str]] = None) -&gt; None:\n    \"\"\"Initialize OCR processor with specified languages.\n\n    Args:\n        languages: List of language codes (default: ['en'])\n    \"\"\"\n    self.languages = languages or ['en']\n    self._reader = None\n</code></pre>"},{"location":"api/tools/#aimq.tools.ocr.processor.OCRProcessor-attributes","title":"Attributes","text":""},{"location":"api/tools/#aimq.tools.ocr.processor.OCRProcessor.reader","title":"<code>reader</code>  <code>property</code>","text":"<p>Get or initialize the EasyOCR reader.</p> <p>Returns:</p> Type Description <code>Reader</code> <p>easyocr.Reader: Initialized EasyOCR reader instance</p>"},{"location":"api/tools/#aimq.tools.ocr.processor.OCRProcessor-functions","title":"Functions","text":""},{"location":"api/tools/#aimq.tools.ocr.processor.OCRProcessor.process_image","title":"<code>process_image(image, save_debug_image=False)</code>","text":"<p>Process an image and return OCR results.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Union[str, Path, Image, bytes]</code> <p>The image to process. Can be one of: - Path to image file (str or Path) - PIL Image object - Bytes of image data</p> required <code>save_debug_image</code> <code>bool</code> <p>If True, includes debug image in output</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: OCR results including: - processing_time: Time taken to process in seconds - text: Extracted text content - debug_image: Optional base64 encoded debug image - detections: List of text detections with coordinates</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If image format is invalid or unreadable</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def process_image(\n    self, \n    image: Union[str, Path, Image.Image, bytes], \n    save_debug_image: bool = False,\n) -&gt; Dict[str, Any]:\n    \"\"\"Process an image and return OCR results.\n\n    Args:\n        image: The image to process. Can be one of:\n            - Path to image file (str or Path)\n            - PIL Image object\n            - Bytes of image data\n        save_debug_image: If True, includes debug image in output\n\n    Returns:\n        Dict[str, Any]: OCR results including:\n            - processing_time: Time taken to process in seconds\n            - text: Extracted text content\n            - debug_image: Optional base64 encoded debug image\n            - detections: List of text detections with coordinates\n\n    Raises:\n        ValueError: If image format is invalid or unreadable\n    \"\"\"\n    start_time = time.time()\n\n    # Convert input to a format EasyOCR can process\n    if isinstance(image, (str, Path)):\n        image_path = str(image)\n        pil_image = Image.open(image_path)\n    elif isinstance(image, bytes):\n        image_stream = io.BytesIO(image)\n        pil_image = Image.open(image_stream)\n        image_path = None\n    elif isinstance(image, Image.Image):\n        pil_image = image\n        image_path = None\n    else:\n        raise ValueError(\"Image must be a file path, PIL Image, or bytes\")\n\n    # Convert PIL Image to numpy array for EasyOCR\n    if pil_image.mode != 'RGB':\n        pil_image = pil_image.convert('RGB')\n    np_image = np.array(pil_image)\n\n    # Read the image with optimized parameters\n    results = self.reader.readtext(\n        np_image,\n        paragraph=False,\n        min_size=20,\n        text_threshold=0.7,\n        link_threshold=0.4,\n        low_text=0.4,\n        width_ths=0.7,\n        height_ths=0.9,\n        ycenter_ths=0.9,\n    )\n\n    # Format initial results\n    detections = []\n    for result in results:\n        if len(result) == 2:\n            bbox, text = result\n            confidence = 1.0\n        else:\n            bbox, text, confidence = result\n\n        x1, y1 = int(bbox[0][0]), int(bbox[0][1])\n        x2, y2 = int(bbox[1][0]), int(bbox[1][1])\n        x3, y3 = int(bbox[2][0]), int(bbox[2][1])\n        x4, y4 = int(bbox[3][0]), int(bbox[3][1])\n\n        detections.append({\n            \"text\": str(text),\n            \"confidence\": float(round(float(confidence), 3)),\n            \"bounding_box\": {\n                \"x\": x1,\n                \"y\": y1,\n                \"width\": x2 - x1,\n                \"height\": y3 - y1\n            }\n        })\n\n    # Group the detections\n    grouped_detections = group_text_boxes(\n        detections,\n        width_growth=20,\n        height_growth=1\n    )\n\n    end_time = time.time()\n    output = {\n        \"processing_time\": float(round(end_time - start_time, 2)),\n        \"detections\": grouped_detections,\n        \"text\": \" \".join(d[\"text\"] for d in grouped_detections)\n    }\n\n    if save_debug_image:\n        debug_image = self._create_debug_image(pil_image, grouped_detections)\n        # Convert debug image to bytes\n        debug_bytes = io.BytesIO()\n        debug_image.save(debug_bytes, format='PNG')\n        output[\"debug_image\"] = debug_bytes.getvalue()\n\n    return output\n</code></pre>"},{"location":"api/tools/#aimq.tools.ocr.processor-functions","title":"Functions","text":""},{"location":"api/tools/#aimq.tools.ocr.processor.boxes_overlap","title":"<code>boxes_overlap(box1, box2)</code>","text":"<p>Check if two boxes overlap at all.</p> <p>Parameters:</p> Name Type Description Default <code>box1</code> <code>Dict[str, int]</code> <p>Dictionary with x, y, width, height</p> required <code>box2</code> <code>Dict[str, int]</code> <p>Dictionary with x, y, width, height</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if boxes overlap</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def boxes_overlap(box1: Dict[str, int], box2: Dict[str, int]) -&gt; bool:\n    \"\"\"\n    Check if two boxes overlap at all.\n\n    Args:\n        box1: Dictionary with x, y, width, height\n        box2: Dictionary with x, y, width, height\n\n    Returns:\n        bool: True if boxes overlap\n    \"\"\"\n    h_overlap = (\n        box1['x'] &lt; box2['x'] + box2['width'] and\n        box2['x'] &lt; box1['x'] + box1['width']\n    )\n\n    v_overlap = (\n        box1['y'] &lt; box2['y'] + box2['height'] and\n        box2['y'] &lt; box1['y'] + box1['height']\n    )\n\n    return h_overlap and v_overlap\n</code></pre>"},{"location":"api/tools/#aimq.tools.ocr.processor.group_text_boxes","title":"<code>group_text_boxes(detections, width_growth=0, height_growth=0)</code>","text":"<p>Group text boxes that are spatially related.</p> <p>This function groups text boxes that are spatially related, starting with overlapping boxes. It can optionally expand boxes horizontally and vertically before grouping to capture nearby text that may be related.</p> <p>Parameters:</p> Name Type Description Default <code>detections</code> <code>List[Dict[str, Any]]</code> <p>List of detection dictionaries containing text and bounding boxes</p> required <code>width_growth</code> <code>int</code> <p>Number of pixels to expand boxes horizontally</p> <code>0</code> <code>height_growth</code> <code>int</code> <p>Number of pixels to expand boxes vertically</p> <code>0</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of grouped text detections with merged bounding boxes</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def group_text_boxes(\n    detections: List[Dict[str, Any]], \n    width_growth: int = 0, \n    height_growth: int = 0\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Group text boxes that are spatially related.\n\n    This function groups text boxes that are spatially related, starting with\n    overlapping boxes. It can optionally expand boxes horizontally and vertically\n    before grouping to capture nearby text that may be related.\n\n    Args:\n        detections: List of detection dictionaries containing text and bounding boxes\n        width_growth: Number of pixels to expand boxes horizontally\n        height_growth: Number of pixels to expand boxes vertically\n\n    Returns:\n        List[Dict[str, Any]]: List of grouped text detections with merged bounding boxes\n    \"\"\"\n    if not detections:\n        return []\n\n    def grow_box(box: Dict[str, int]) -&gt; Dict[str, int]:\n        \"\"\"Helper to expand a box by the growth parameters\"\"\"\n        return {\n            'x': box['x'],\n            'y': box['y'],\n            'width': box['width'] + width_growth,\n            'height': box['height'] + height_growth\n        }\n\n    groups = [[det] for det in detections]\n\n    while True:\n        merged = False\n        new_groups = []\n        used = set()\n\n        for i, group1 in enumerate(groups):\n            if i in used:\n                continue\n\n            merged_group = group1.copy()\n            used.add(i)\n\n            box1 = grow_box(merge_boxes([det['bounding_box'] for det in merged_group]))\n\n            for j, group2 in enumerate(groups):\n                if j in used:\n                    continue\n\n                box2 = merge_boxes([det['bounding_box'] for det in group2])\n\n                if boxes_overlap(box1, box2):\n                    merged_group.extend(group2)\n                    used.add(j)\n                    box1 = grow_box(merge_boxes([det['bounding_box'] for det in merged_group]))\n                    merged = True\n\n            new_groups.append(merged_group)\n\n        if not merged:\n            break\n\n        groups = new_groups\n\n    return [{\n        \"text\": ' '.join(det['text'] for det in sorted(\n            group,\n            key=lambda d: (d['bounding_box']['y'], d['bounding_box']['x'])\n        )),\n        \"confidence\": float(round(\n            sum(det['confidence'] for det in group) / len(group),\n            3\n        )),\n        \"bounding_box\": merge_boxes([det['bounding_box'] for det in group])\n    } for group in groups]\n</code></pre>"},{"location":"api/tools/#aimq.tools.ocr.processor.merge_boxes","title":"<code>merge_boxes(boxes)</code>","text":"<p>Merge a list of bounding boxes into a single box that encompasses all of them.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>List[Dict[str, int]]</code> <p>List of dictionaries with x, y, width, height</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Optional[Dict[str, int]]</code> <p>Merged bounding box or None if input is empty</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def merge_boxes(boxes: List[Dict[str, int]]) -&gt; Optional[Dict[str, int]]:\n    \"\"\"\n    Merge a list of bounding boxes into a single box that encompasses all of them.\n\n    Args:\n        boxes: List of dictionaries with x, y, width, height\n\n    Returns:\n        dict: Merged bounding box or None if input is empty\n    \"\"\"\n    if not boxes:\n        return None\n\n    min_x = min(box['x'] for box in boxes)\n    min_y = min(box['y'] for box in boxes)\n    max_x = max(box['x'] + box['width'] for box in boxes)\n    max_y = max(box['y'] + box['height'] for box in boxes)\n\n    return {\n        'x': int(min_x),\n        'y': int(min_y),\n        'width': int(max_x - min_x),\n        'height': int(max_y - min_y)\n    }\n</code></pre>"},{"location":"api/tools/#storage-tools","title":"Storage Tools","text":""},{"location":"api/tools/#supabase-storage","title":"Supabase Storage","text":""},{"location":"api/tools/#aimq.tools.supabase.read_file","title":"<code>aimq.tools.supabase.read_file</code>","text":"<p>Tool for reading files from Supabase Storage.</p>"},{"location":"api/tools/#aimq.tools.supabase.read_file-classes","title":"Classes","text":""},{"location":"api/tools/#aimq.tools.supabase.read_file.ReadFile","title":"<code>ReadFile</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for reading files from Supabase Storage.</p>"},{"location":"api/tools/#aimq.tools.supabase.read_file.ReadFileInput","title":"<code>ReadFileInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for ReadFile.</p>"},{"location":"api/tools/#aimq.tools.supabase.write_file","title":"<code>aimq.tools.supabase.write_file</code>","text":"<p>Tool for writing files to Supabase Storage.</p>"},{"location":"api/tools/#aimq.tools.supabase.write_file-classes","title":"Classes","text":""},{"location":"api/tools/#aimq.tools.supabase.write_file.WriteFile","title":"<code>WriteFile</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for writing files to Supabase Storage.</p>"},{"location":"api/tools/#aimq.tools.supabase.write_file.WriteFileInput","title":"<code>WriteFileInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for WriteFile.</p>"},{"location":"api/tools/#supabase-database","title":"Supabase Database","text":""},{"location":"api/tools/#aimq.tools.supabase.read_record","title":"<code>aimq.tools.supabase.read_record</code>","text":"<p>Tool for reading records from Supabase.</p>"},{"location":"api/tools/#aimq.tools.supabase.read_record-classes","title":"Classes","text":""},{"location":"api/tools/#aimq.tools.supabase.read_record.ReadRecord","title":"<code>ReadRecord</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for reading records from Supabase.</p>"},{"location":"api/tools/#aimq.tools.supabase.read_record.ReadRecordInput","title":"<code>ReadRecordInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for ReadRecord.</p>"},{"location":"api/tools/#aimq.tools.supabase.write_record","title":"<code>aimq.tools.supabase.write_record</code>","text":"<p>Tool for writing records to Supabase.</p>"},{"location":"api/tools/#aimq.tools.supabase.write_record-classes","title":"Classes","text":""},{"location":"api/tools/#aimq.tools.supabase.write_record.WriteRecord","title":"<code>WriteRecord</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for writing records to Supabase.</p>"},{"location":"api/tools/#aimq.tools.supabase.write_record.WriteRecordInput","title":"<code>WriteRecordInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for WriteRecord.</p>"},{"location":"development/contributing/","title":"Contributing to AIMQ","text":"<p>We love your input! We want to make contributing to AIMQ as easy and transparent as possible, whether it's:</p> <ul> <li>Reporting a bug</li> <li>Discussing the current state of the code</li> <li>Submitting a fix</li> <li>Proposing new features</li> <li>Becoming a maintainer</li> </ul>"},{"location":"development/contributing/#development-process","title":"Development Process","text":"<p>We use GitHub to host code, to track issues and feature requests, as well as accept pull requests.</p> <ol> <li>Fork the repo and create your branch from <code>main</code></li> <li>If you've added code that should be tested, add tests</li> <li>If you've changed APIs, update the documentation</li> <li>Ensure the test suite passes</li> <li>Make sure your code follows our coding conventions</li> <li>Issue that pull request!</li> </ol>"},{"location":"development/contributing/#local-development-setup","title":"Local Development Setup","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/yourusername/aimq.git\ncd aimq\n</code></pre></p> </li> <li> <p>Install dependencies:    <pre><code>poetry install\n</code></pre></p> </li> <li> <p>Set up pre-commit hooks:    <pre><code>poetry run pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>We use pytest for our test suite:</p> <pre><code>poetry run pytest\n</code></pre> <p>For coverage report:</p> <pre><code>poetry run pytest --cov=src\n</code></pre>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>We follow these coding conventions:</p> <ol> <li>Type Hints</li> <li>All function parameters and return values must have type hints</li> <li>Use <code>Optional</code> for parameters that can be None</li> <li> <p>Use <code>Union</code> for parameters that can be multiple types</p> </li> <li> <p>Docstrings</p> </li> <li>All public functions, classes, and modules must have docstrings</li> <li>Use Google style docstrings</li> <li> <p>Include Args, Returns, and Raises sections</p> </li> <li> <p>Naming Conventions</p> </li> <li>Classes: PascalCase</li> <li>Functions/Methods: snake_case</li> <li>Variables: snake_case</li> <li>Constants: SCREAMING_SNAKE_CASE</li> </ol>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update the README.md with details of changes to the interface</li> <li>Update the documentation with any new features or changes</li> <li>The PR will be merged once you have the sign-off of at least one maintainer</li> </ol>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under its MIT License.</p>"},{"location":"development/release-process/","title":"Release Process","text":"<p>This document outlines the process for creating and publishing new releases of AIMQ.</p>"},{"location":"development/release-process/#version-numbering","title":"Version Numbering","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR version for incompatible API changes</li> <li>MINOR version for new functionality in a backward compatible manner</li> <li>PATCH version for backward compatible bug fixes</li> </ul>"},{"location":"development/release-process/#release-checklist","title":"Release Checklist","text":"<ol> <li>Update Version</li> <li>Update version in <code>pyproject.toml</code></li> <li>Update CHANGELOG.md</li> <li> <p>Commit changes: <code>git commit -m \"Bump version to X.Y.Z\"</code></p> </li> <li> <p>Run Tests <pre><code>poetry run pytest\npoetry run pytest --cov=src\n</code></pre></p> </li> <li> <p>Build Documentation <pre><code>poetry run mkdocs build\n</code></pre></p> </li> <li> <p>Create Release Branch <pre><code>git checkout -b release/vX.Y.Z\ngit push origin release/vX.Y.Z\n</code></pre></p> </li> <li> <p>Create Pull Request</p> </li> <li>Title: \"Release vX.Y.Z\"</li> <li>Include changelog in description</li> <li> <p>Get required approvals</p> </li> <li> <p>Merge and Tag <pre><code>git checkout main\ngit pull origin main\ngit tag -a vX.Y.Z -m \"Release vX.Y.Z\"\ngit push origin vX.Y.Z\n</code></pre></p> </li> <li> <p>Build and Publish <pre><code>poetry build\npoetry publish\n</code></pre></p> </li> <li> <p>Deploy Documentation <pre><code>poetry run mkdocs gh-deploy\n</code></pre></p> </li> </ol>"},{"location":"development/release-process/#post-release","title":"Post-Release","text":"<ol> <li>Update version to next development version in <code>pyproject.toml</code></li> <li>Create new section in CHANGELOG.md for unreleased changes</li> <li>Announce release in appropriate channels</li> </ol>"},{"location":"development/release-process/#hotfix-process","title":"Hotfix Process","text":"<p>For critical bugs in production:</p> <ol> <li>Create hotfix branch from the release tag</li> <li>Fix the bug and update patch version</li> <li>Create PR back to both <code>main</code> and the release branch</li> <li>Follow steps 6-8 from the release checklist</li> </ol>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide covers the testing practices and requirements for AIMQ.</p>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>Tests are organized to mirror the source code structure:</p> <pre><code>tests/\n\u251c\u2500\u2500 aimq/\n\u2502   \u251c\u2500\u2500 test_worker.py\n\u2502   \u251c\u2500\u2500 test_queue.py\n\u2502   \u251c\u2500\u2500 test_job.py\n\u2502   \u251c\u2500\u2500 clients/\n\u2502   \u2502   \u2514\u2500\u2500 test_supabase_client.py\n\u2502   \u2514\u2500\u2500 tools/\n\u2502       \u251c\u2500\u2500 ocr/\n\u2502       \u2502   \u2514\u2500\u2500 test_image_ocr.py\n\u2502       \u2514\u2500\u2500 pdf/\n\u2502           \u2514\u2500\u2500 test_pdf_processor.py\n\u2514\u2500\u2500 conftest.py\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<p>Run all tests: <pre><code>poetry run pytest\n</code></pre></p> <p>Run with coverage: <pre><code>poetry run pytest --cov=src\n</code></pre></p> <p>Run specific test file: <pre><code>poetry run pytest tests/aimq/test_worker.py\n</code></pre></p> <p>Run tests matching a pattern: <pre><code>poetry run pytest -k \"test_process\"\n</code></pre></p>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#test-requirements","title":"Test Requirements","text":"<ol> <li>Coverage Requirements</li> <li>Minimum 80% code coverage for new code</li> <li>Critical components require 90%+ coverage</li> <li> <p>Integration tests required for public APIs</p> </li> <li> <p>Test Types</p> </li> <li>Unit Tests: Test individual components in isolation</li> <li>Integration Tests: Test component interactions</li> <li>Functional Tests: Test complete features</li> <li>Async Tests: Use pytest-asyncio for async code</li> </ol>"},{"location":"development/testing/#test-structure_1","title":"Test Structure","text":"<p>Use pytest fixtures for test setup:</p> <pre><code>import pytest\nfrom aimq import Worker\n\n@pytest.fixture\ndef worker():\n    worker = Worker()\n    worker.register_queue(\"test_queue\")\n    return worker\n\ndef test_process_job(worker):\n    result = worker.process({\"data\": \"test\"})\n    assert result[\"status\"] == \"success\"\n</code></pre>"},{"location":"development/testing/#mocking","title":"Mocking","text":"<p>Use pytest's monkeypatch for mocking:</p> <pre><code>def test_supabase_client(monkeypatch):\n    mock_client = MockSupabaseClient()\n    monkeypatch.setattr(\"aimq.clients.supabase.client\", mock_client)\n    # Test code here\n</code></pre>"},{"location":"development/testing/#cicd-pipeline","title":"CI/CD Pipeline","text":"<p>Our GitHub Actions pipeline runs tests on:</p> <ul> <li>Pull requests to main branch</li> <li>Push to main branch</li> <li>Release tags</li> </ul> <p>The pipeline:</p> <ol> <li>Runs all tests</li> <li>Generates coverage report</li> <li>Checks code style</li> <li>Builds documentation</li> </ol>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>AIMQ can be configured through environment variables and requires proper Supabase queue setup.</p>"},{"location":"getting-started/configuration/#supabase-queue-setup","title":"Supabase Queue Setup","text":"<ol> <li>Enable Queue Integration:</li> <li>Go to your Supabase project dashboard</li> <li>Navigate to Database \u2192 Extensions</li> <li>Enable the \"pg_net\" and \"pg_cron\" extensions if not already enabled</li> <li>Navigate to Database \u2192 Queues (Beta)</li> <li>Click \"Enable Queue\"</li> <li> <p>Make sure to enable \"Expose Queues via PostgREST\"</p> </li> <li> <p>Create Queues:</p> </li> <li>In the Queues interface, click \"Create a new queue\"</li> <li>Give your queue a name (this will be referenced in your <code>@worker.task</code> decorators)</li> <li>Configure queue settings as needed</li> </ol> <p>For more details, see the Supabase Queue Documentation.</p>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables are supported:</p> <pre><code># Required Supabase Configuration\nSUPABASE_URL=your-project-url\nSUPABASE_KEY=your-service-role-key  # Must be service role key, not anon key\n\n# Worker Configuration (Optional)\nWORKER_NAME=my-worker  # Default: 'peon'\nWORKER_LOG_LEVEL=info  # Default: 'info'\nWORKER_IDLE_WAIT=10.0  # Default: 10.0 seconds\n\n# LangChain Configuration (Optional)\nLANGCHAIN_TRACING_V2=true  # Enable LangChain tracing\nLANGCHAIN_ENDPOINT=https://api.smith.langchain.com\nLANGCHAIN_API_KEY=your-langchain-api-key\nLANGCHAIN_PROJECT=your-project-name\n\n# OpenAI Configuration (If using OpenAI)\nOPENAI_API_KEY=your-openai-api-key\n</code></pre>"},{"location":"getting-started/configuration/#configuration-file","title":"Configuration File","text":"<p>You can create a <code>.env</code> file in your project root:</p> <pre><code># .env\nSUPABASE_URL=your-project-url\nSUPABASE_KEY=your-service-role-key\nWORKER_NAME=my-worker\n</code></pre>"},{"location":"getting-started/configuration/#using-poetry","title":"Using Poetry","text":"<p>Since this project uses Poetry for dependency management, you can:</p> <ol> <li> <p>Install dependencies: <pre><code>poetry install\n</code></pre></p> </li> <li> <p>Run with environment variables: <pre><code>poetry run python -m aimq.worker\n</code></pre></p> </li> </ol> <p>Or use your <code>.env</code> file: <pre><code>poetry run python -m aimq.worker\n</code></pre></p>"},{"location":"getting-started/configuration/#configuration-in-code","title":"Configuration in Code","text":"<p>Access configuration in your code:</p> <pre><code>from aimq.config import config\n\n# Access configuration values\nsupabase_url = config.supabase_url\nworker_name = config.worker_name\n\n# Create a worker with custom configuration\nfrom aimq import Worker\n\nworker = Worker(\n    name=\"custom-worker\",\n    log_level=\"debug\",\n    idle_wait=5.0\n)\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>See the Quick Start Guide for usage examples</li> <li>Learn about Worker Configuration for advanced settings</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>AIMQ can be installed using pip or poetry. We recommend using poetry for development.</p>"},{"location":"getting-started/installation/#using-poetry-recommended","title":"Using Poetry (Recommended)","text":"<pre><code>poetry add aimq\n</code></pre> <p>Or clone the repository and install in development mode:</p> <pre><code>git clone https://github.com/bldxio/aimq.git\ncd aimq\npoetry install\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install aimq\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>AIMQ requires Python 3.11 or later and has the following main dependencies:</p> <ul> <li>easyocr: For OCR capabilities</li> <li>supabase: For queue and storage management</li> <li>langchain: For AI model integration</li> <li>pydantic: For data validation and settings management</li> </ul> <p>These dependencies will be automatically installed when you install AIMQ.</p>"},{"location":"getting-started/installation/#configuration","title":"Configuration","text":"<p>After installation, you'll need to configure your Supabase credentials. Create a <code>.env</code> file in your project root:</p> <pre><code>SUPABASE_URL=your-project-url\nSUPABASE_KEY=your-api-key\n</code></pre> <p>Or set them as environment variables:</p> <pre><code>export SUPABASE_URL=your-project-url\nexport SUPABASE_KEY=your-api-key\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>You can verify your installation by running:</p> <pre><code>poetry run aimq --version\n</code></pre> <p>This should display the version number of your AIMQ installation.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with AIMQ (AI Message Queue) quickly.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ol> <li>A Supabase project with Queue integration enabled</li> <li>\"Expose Queues via PostgREST\" setting turned on</li> <li>At least one queue created in your Supabase project</li> </ol>"},{"location":"getting-started/quickstart/#environment-setup","title":"Environment Setup","text":"<p>Configure your environment variables:</p> <pre><code>SUPABASE_URL=your-project-url\nSUPABASE_KEY=your-service-role-key\nWORKER_NAME=my-worker  # Optional, defaults to 'peon'\n</code></pre>"},{"location":"getting-started/quickstart/#using-workers-recommended","title":"Using Workers (Recommended)","text":"<p>The Worker class provides a convenient way to define and manage queue processors using decorators.</p> <ol> <li>Create a <code>tasks.py</code> file to define your queue processors:</li> </ol> <pre><code>\"\"\"\nExample tasks.py file demonstrating queue processors using AIMQ.\n\"\"\"\nfrom aimq import Worker\nfrom langchain.prompts import ChatPromptTemplate\nfrom langchain.chat_models import ChatOpenAI\n\n# Initialize the worker\nworker = Worker()\n\n# Define a simple task\n@worker.task(queue=\"hello_world\")\ndef hello_world(data):\n    \"\"\"Simple task that returns a greeting message.\"\"\"\n    return {\"message\": f\"Hello {data.get('name', 'World')}!\"}\n\n# Define a LangChain-powered task\n@worker.task(queue=\"ai_processor\", timeout=300)\ndef process_with_ai(data):\n    \"\"\"Process text using LangChain.\"\"\"\n    # Create a LangChain runnable\n    prompt = ChatPromptTemplate.from_template(\"Summarize this text: {text}\")\n    model = ChatOpenAI()\n    chain = prompt | model\n\n    # Process the input\n    return chain.with_config({\"text\": data.get(\"text\", \"\")})\n\nif __name__ == \"__main__\":\n    # This allows the file to be run directly with: python tasks.py\n    worker.start()\n</code></pre> <ol> <li>Run your worker:</li> </ol> <p>Option 1: Using the <code>aimq start</code> command: <pre><code># Run tasks.py with default settings\naimq start tasks.py\n\n# Run with debug logging\naimq start tasks.py --debug\n\n# Run with specific log level\naimq start tasks.py --log-level debug\n</code></pre></p> <p>Option 2: Running the file directly: <pre><code># Run tasks.py directly\npython tasks.py\n</code></pre></p> <ol> <li>Send jobs to your queues:</li> </ol> <pre><code>from aimq import Worker\n\n# Create a worker instance (make sure tasks are defined first)\nworker = Worker()\n\n# Send a job to the hello_world queue\nworker.send(\"hello_world\", {\"name\": \"Alice\"})\n\n# Send a job to the ai_processor queue\nworker.send(\"ai_processor\", {\n    \"text\": \"LangChain is a framework for developing applications powered by language models.\"\n})\n</code></pre>"},{"location":"getting-started/quickstart/#using-queues-directly","title":"Using Queues Directly","text":"<p>You can also use the Queue class directly if you want more control or don't need the Worker abstraction.</p> <pre><code>from aimq.queue import Queue\nfrom langchain.prompts import ChatPromptTemplate\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain_core.runnables import RunnableLambda\n\n# Create a processor function\ndef process_text(data):\n    prompt = ChatPromptTemplate.from_template(\"Summarize this text: {text}\")\n    model = ChatOpenAI()\n    chain = prompt | model\n    result = chain.invoke({\"text\": data.get(\"text\", \"\")})\n    return {\"summary\": result.content}\n\n# Create a queue with a runnable\nqueue = Queue(\n    runnable=RunnableLambda(process_text, name=\"text_processor\"),\n    timeout=300,\n    delete_on_finish=True,\n    tags=[\"ai\", \"text\"]\n)\n\n# Send a job to the queue\njob_id = queue.send({\n    \"text\": \"LangChain is a framework for developing applications powered by language models.\"\n})\n\n# Process a single job\nresult = queue.work()\n</code></pre>"},{"location":"getting-started/quickstart/#advanced-features","title":"Advanced Features","text":""},{"location":"getting-started/quickstart/#delayed-jobs","title":"Delayed Jobs","text":"<pre><code># Using Worker\nworker.send(\"hello_world\", {\"name\": \"Bob\"}, delay=60)\n\n# Using Queue directly\nqueue.send({\"text\": \"Process this later\"}, delay=60)\n</code></pre>"},{"location":"getting-started/quickstart/#task-configuration","title":"Task Configuration","text":"<pre><code>@worker.task(\n    queue=\"important_task\",\n    timeout=600,  # 10 minute timeout\n    delete_on_finish=True,  # Delete instead of archive completed jobs\n    tags=[\"production\", \"high-priority\"]  # Add metadata tags\n)\ndef process_important_task(data):\n    # Process important task\n    return {\"status\": \"completed\"}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about configuration options</li> <li>Explore the API Reference</li> </ul>"},{"location":"reference/aimq/","title":"aimq","text":""},{"location":"reference/aimq/#aimq","title":"<code>aimq</code>","text":"<p>AIMQ - AI Message Queue</p>"},{"location":"reference/aimq/attachment/","title":"aimq.attachment","text":""},{"location":"reference/aimq/attachment/#aimq.attachment","title":"<code>aimq.attachment</code>","text":""},{"location":"reference/aimq/config/","title":"aimq.config","text":""},{"location":"reference/aimq/config/#aimq.config","title":"<code>aimq.config</code>","text":""},{"location":"reference/aimq/config/#aimq.config-classes","title":"Classes","text":""},{"location":"reference/aimq/config/#aimq.config.Config","title":"<code>Config</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Configuration class for the application.</p>"},{"location":"reference/aimq/config/#aimq.config-functions","title":"Functions","text":""},{"location":"reference/aimq/config/#aimq.config.get_config","title":"<code>get_config()</code>  <code>cached</code>","text":"<p>Get the configuration singleton.</p> Source code in <code>src/aimq/config.py</code> <pre><code>@lru_cache()\ndef get_config() -&gt; Config:\n    \"\"\"Get the configuration singleton.\"\"\"\n    return Config()\n</code></pre>"},{"location":"reference/aimq/helpers/","title":"aimq.helpers","text":""},{"location":"reference/aimq/helpers/#aimq.helpers","title":"<code>aimq.helpers</code>","text":""},{"location":"reference/aimq/job/","title":"aimq.job","text":""},{"location":"reference/aimq/job/#aimq.job","title":"<code>aimq.job</code>","text":""},{"location":"reference/aimq/job/#aimq.job-classes","title":"Classes","text":""},{"location":"reference/aimq/job/#aimq.job.Job","title":"<code>Job</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A job in the queue.</p> <p>This class represents a job that can be processed by a worker. Each job has a unique identifier, metadata about its processing status, and the actual data to be processed.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier for the job (aliased as msg_id)</p> <code>attempt</code> <code>int</code> <p>Number of times this job has been attempted (aliased as read_ct)</p> <code>updated_at</code> <code>datetime</code> <p>Timestamp of last update</p> <code>enqueued_at</code> <code>datetime</code> <p>Timestamp when job was added to queue</p> <code>expires_at</code> <code>datetime</code> <p>Timestamp when job expires (aliased as vt)</p> <code>data</code> <code>dict[str, Any]</code> <p>The actual job data to process (aliased as message)</p> <code>status</code> <code>str</code> <p>Current status of the job</p> <code>queue</code> <code>Optional[str]</code> <p>Optional name of the queue this job belongs to</p>"},{"location":"reference/aimq/job/#aimq.job.Job-attributes","title":"Attributes","text":""},{"location":"reference/aimq/job/#aimq.job.Job.popped","title":"<code>popped</code>  <code>property</code>","text":"<p>Check if the job has been popped from the queue.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the job has been popped, False otherwise</p>"},{"location":"reference/aimq/job/#aimq.job.Job-functions","title":"Functions","text":""},{"location":"reference/aimq/job/#aimq.job.Job.from_response","title":"<code>from_response(response_data, queue=None, popped=False)</code>  <code>classmethod</code>","text":"<p>Create a Job instance from API response data.</p> <p>Parameters:</p> Name Type Description Default <code>response_data</code> <code>dict</code> <p>Raw response data from the API</p> required <code>queue</code> <code>Optional[str]</code> <p>Optional name of the queue this job belongs to</p> <code>None</code> <code>popped</code> <code>bool</code> <p>Whether this job has been popped from the queue</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Job</code> <code>Job</code> <p>A new Job instance initialized with the response data</p> Source code in <code>src/aimq/job.py</code> <pre><code>@classmethod\ndef from_response(cls, response_data: dict, queue: Optional[str] = None, popped: bool = False) -&gt; 'Job':\n    \"\"\"Create a Job instance from API response data.\n\n    Args:\n        response_data: Raw response data from the API\n        queue: Optional name of the queue this job belongs to\n        popped: Whether this job has been popped from the queue\n\n    Returns:\n        Job: A new Job instance initialized with the response data\n    \"\"\"\n    job = cls(**response_data)\n    job._popped = popped\n    job.queue = queue\n    return job\n</code></pre>"},{"location":"reference/aimq/logger/","title":"aimq.logger","text":""},{"location":"reference/aimq/logger/#aimq.logger","title":"<code>aimq.logger</code>","text":""},{"location":"reference/aimq/queue/","title":"aimq.queue","text":""},{"location":"reference/aimq/queue/#aimq.queue","title":"<code>aimq.queue</code>","text":""},{"location":"reference/aimq/queue/#aimq.queue-classes","title":"Classes","text":""},{"location":"reference/aimq/queue/#aimq.queue.Queue","title":"<code>Queue</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A queue class that manages workflows with configurable parameters.</p>"},{"location":"reference/aimq/queue/#aimq.queue.Queue-attributes","title":"Attributes","text":""},{"location":"reference/aimq/queue/#aimq.queue.Queue.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the queue name from the runnable.</p>"},{"location":"reference/aimq/queue/#aimq.queue.Queue-functions","title":"Functions","text":""},{"location":"reference/aimq/queue/#aimq.queue.Queue.finish","title":"<code>finish(job)</code>","text":"<p>Finish processing a job.</p> <p>If the job was popped, do nothing. Otherwise, either archive or delete based on delete_on_finish setting.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>Job</code> <p>The job to finish</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operation was successful</p> Source code in <code>src/aimq/queue.py</code> <pre><code>def finish(self, job: Job) -&gt; bool:\n    \"\"\"Finish processing a job.\n\n    If the job was popped, do nothing.\n    Otherwise, either archive or delete based on delete_on_finish setting.\n\n    Args:\n        job: The job to finish\n\n    Returns:\n        bool: True if the operation was successful\n    \"\"\"\n    if job._popped:\n        self.logger.debug(f\"Job {job.id} was popped, no cleanup needed\")\n        return True\n\n    try:\n        if self.delete_on_finish:\n            self.provider.delete(self.name, job.id)\n            self.logger.info(f\"Deleted job {job.id} from queue {self.name}\")\n        else:\n            self.provider.archive(self.name, job.id)\n            self.logger.info(f\"Archived job {job.id} from queue {self.name}\")\n        return True\n    except Exception as e:\n        self.logger.error(f\"Error finishing job {job.id}: {str(e)}\")\n        return False\n</code></pre>"},{"location":"reference/aimq/queue/#aimq.queue.Queue.get_runtime_config","title":"<code>get_runtime_config(job)</code>","text":"<p>Create a runtime configuration for the job.</p> <p>Parameters:</p> Name Type Description Default <code>job</code> <code>Job</code> <p>The job to create configuration for</p> required <p>Returns:</p> Name Type Description <code>RunnableConfig</code> <code>RunnableConfig</code> <p>Configuration for running the job</p> Source code in <code>src/aimq/queue.py</code> <pre><code>def get_runtime_config(self, job: Job) -&gt; RunnableConfig:\n    \"\"\"Create a runtime configuration for the job.\n\n    Args:\n        job: The job to create configuration for\n\n    Returns:\n        RunnableConfig: Configuration for running the job\n    \"\"\"\n    return RunnableConfig(\n        metadata={\n            \"worker\": self.worker_name,\n            \"queue\": self.name, \n            \"job\": job.id, \n        }, \n        tags=self.tags,\n        configurable=job.data\n    )\n</code></pre>"},{"location":"reference/aimq/queue/#aimq.queue.Queue.next","title":"<code>next()</code>","text":"<p>Check for new jobs in the queue.</p> <p>Returns:</p> Type Description <code>Job | None</code> <p>Optional[Job]: Next job if available, None otherwise</p> Source code in <code>src/aimq/queue.py</code> <pre><code>def next(self) -&gt; Job | None:\n    \"\"\"Check for new jobs in the queue.\n\n    Returns:\n        Optional[Job]: Next job if available, None otherwise\n    \"\"\"\n    try:\n        if self.timeout == 0:\n            job = self.provider.pop(self.name)\n        else:\n            jobs = self.provider.read(self.name, self.timeout, 1)\n            job = jobs[0] if jobs else None\n        if job:\n            self.logger.debug(f\"Retrieved job {job.id} from queue {self.name}\")\n        return job\n    except QueueNotFoundError as e:\n        self.logger.error(f\"Queue {self.name} not found\", str(e))\n</code></pre>"},{"location":"reference/aimq/queue/#aimq.queue.Queue.run","title":"<code>run(job)</code>","text":"<p>Process a  specific job using the configured runnable.</p> Source code in <code>src/aimq/queue.py</code> <pre><code>def run(self, job: Job) -&gt; Any:\n    \"\"\"Process a  specific job using the configured runnable.\"\"\"\n    runtime_config = self.get_runtime_config(job)\n    return self.runnable.invoke(job.data, runtime_config)\n</code></pre>"},{"location":"reference/aimq/queue/#aimq.queue.Queue.send","title":"<code>send(data, delay=None)</code>","text":"<p>Add a message to the queue.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Data payload to send</p> required <code>delay</code> <code>int | None</code> <p>Optional delay in seconds before the message becomes visible</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The ID of the added message</p> Source code in <code>src/aimq/queue.py</code> <pre><code>def send(self, data: dict[str, Any], delay: int | None = None) -&gt; int:\n    \"\"\"Add a message to the queue.\n\n    Args:\n        data: Data payload to send\n        delay: Optional delay in seconds before the message becomes visible\n\n    Returns:\n        int: The ID of the added message\n    \"\"\"\n    job_id = self.provider.send(self.name, data, delay)\n    self.logger.info(f\"Sent job {job_id} to queue {self.name}\", data)\n    return job_id\n</code></pre>"},{"location":"reference/aimq/queue/#aimq.queue.Queue.send_batch","title":"<code>send_batch(data_list, delay=None)</code>","text":"<p>Add a batch of messages to the queue.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[dict[str, Any]]</code> <p>List of data payloads to send</p> required <code>delay</code> <code>int | None</code> <p>Optional delay in seconds before the messages become visible</p> <code>None</code> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: List of IDs of added messages</p> Source code in <code>src/aimq/queue.py</code> <pre><code>def send_batch(self, data_list: list[dict[str, Any]], delay: int | None = None) -&gt; List[int]:\n    \"\"\"Add a batch of messages to the queue.\n\n    Args:\n        data_list: List of data payloads to send\n        delay: Optional delay in seconds before the messages become visible\n\n    Returns:\n        List[int]: List of IDs of added messages\n    \"\"\"\n    job_ids = self.provider.send_batch(self.name, data_list, delay)\n    self.logger.info(f\"Sent batch of {len(job_ids)} jobs to queue {self.name}\")\n    return job_ids\n</code></pre>"},{"location":"reference/aimq/queue/#aimq.queue.Queue.work","title":"<code>work()</code>","text":"<p>Process jobs in the queue using the configured runnable.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Result from processing each job</p> Source code in <code>src/aimq/queue.py</code> <pre><code>def work(self) -&gt; Any:\n    \"\"\"Process jobs in the queue using the configured runnable.\n\n    Returns:\n        Any: Result from processing each job\n    \"\"\"\n    job = self.next()\n    if job is None:\n        return None\n\n    self.logger.info(f\"Processing job {job.id} in queue {self.name}\", job.data)\n    try:\n        result = self.run(job)\n        self.logger.info(f\"Job {job.id} processed successfully\", result)\n        self.finish(job)\n        return result\n    except Exception as e:\n        self.logger.error(f\"Error processing job {job.id}: {str(e)}\", job.data)\n        raise\n</code></pre>"},{"location":"reference/aimq/queue/#aimq.queue.QueueNotFoundError","title":"<code>QueueNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to access a queue that does not exist.</p>"},{"location":"reference/aimq/utils/","title":"aimq.utils","text":""},{"location":"reference/aimq/utils/#aimq.utils","title":"<code>aimq.utils</code>","text":"<p>Utility functions for the core package.</p>"},{"location":"reference/aimq/utils/#aimq.utils-functions","title":"Functions","text":""},{"location":"reference/aimq/utils/#aimq.utils.add_to_path","title":"<code>add_to_path(path)</code>","text":"<p>Temporarily add a directory to sys.path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Directory to add to sys.path</p> required <p>Yields:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/aimq/utils.py</code> <pre><code>@contextmanager\ndef add_to_path(path: str) -&gt; Generator[None, None, None]:\n    \"\"\"Temporarily add a directory to sys.path.\n\n    Args:\n        path: Directory to add to sys.path\n\n    Yields:\n        None\n    \"\"\"\n    sys.path.insert(0, path)\n    try:\n        yield\n    finally:\n        sys.path.pop(0)\n</code></pre>"},{"location":"reference/aimq/utils/#aimq.utils.encode_image","title":"<code>encode_image(image)</code>","text":"<p>Encode a PIL Image as a base64 string.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>PIL Image to encode</p> required <p>Returns:</p> Type Description <code>str</code> <p>Base64 encoded string of the image in PNG format</p> Source code in <code>src/aimq/utils.py</code> <pre><code>def encode_image(image: Image.Image) -&gt; str:\n    \"\"\"\n    Encode a PIL Image as a base64 string.\n\n    Args:\n        image: PIL Image to encode\n\n    Returns:\n        Base64 encoded string of the image in PNG format\n    \"\"\"\n    buffered = BytesIO()\n    image.save(buffered, format=\"PNG\")\n    return base64.b64encode(buffered.getvalue()).decode('utf-8')\n</code></pre>"},{"location":"reference/aimq/utils/#aimq.utils.load_module","title":"<code>load_module(module_path, *, add_to_sys_path=True)</code>","text":"<p>Load a Python module from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>Path</code> <p>Path to the Python file to load</p> required <code>add_to_sys_path</code> <code>bool</code> <p>Whether to add the module's parent directory to sys.path</p> <code>True</code> <p>Returns:</p> Type Description <code>Any</code> <p>The loaded module</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the module cannot be loaded</p> Source code in <code>src/aimq/utils.py</code> <pre><code>def load_module(module_path: Path, *, add_to_sys_path: bool = True) -&gt; Any:\n    \"\"\"Load a Python module from a file path.\n\n    Args:\n        module_path: Path to the Python file to load\n        add_to_sys_path: Whether to add the module's parent directory to sys.path\n\n    Returns:\n        The loaded module\n\n    Raises:\n        ImportError: If the module cannot be loaded\n    \"\"\"\n    if add_to_sys_path:\n        # Add the parent directory to Python path\n        module_dir = module_path.parent\n        sys.path.insert(0, str(module_dir.parent))\n\n    try:\n        # Import the module using the package name\n        package_name = module_path.parent.name\n        module_name = module_path.stem\n        full_module_name = f\"{package_name}.{module_name}\"\n\n        # Import the module\n        spec = importlib.util.spec_from_file_location(full_module_name, module_path)\n        if spec is None or spec.loader is None:\n            raise ImportError(f\"Could not load module from {module_path}\")\n\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[full_module_name] = module  # Register the module in sys.modules\n        spec.loader.exec_module(module)\n\n        return module\n    finally:\n        if add_to_sys_path:\n            # Remove the added path to avoid polluting sys.path\n            sys.path.pop(0)\n</code></pre>"},{"location":"reference/aimq/worker/","title":"aimq.worker","text":""},{"location":"reference/aimq/worker/#aimq.worker","title":"<code>aimq.worker</code>","text":""},{"location":"reference/aimq/worker/#aimq.worker-classes","title":"Classes","text":""},{"location":"reference/aimq/worker/#aimq.worker.Worker","title":"<code>Worker</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Main worker class that manages job processing across multiple queues.</p> <p>The Worker class is responsible for managing multiple queues and their associated processing threads. It handles queue registration, thread management, and provides a clean interface for starting and stopping job processing.</p> <p>Attributes:</p> Name Type Description <code>queues</code> <code>OrderedDict[str, Queue]</code> <p>Ordered dictionary of registered queues</p> <code>logger</code> <code>Logger</code> <p>Logger instance for recording worker activities</p> <code>log_level</code> <code>LogLevel | str</code> <p>Current logging level</p> <code>running</code> <code>LogLevel | str</code> <p>Threading event controlling worker execution</p> <code>thread</code> <code>Optional[WorkerThread]</code> <p>Worker thread instance</p>"},{"location":"reference/aimq/worker/#aimq.worker.Worker-functions","title":"Functions","text":""},{"location":"reference/aimq/worker/#aimq.worker.Worker.assign","title":"<code>assign(runnable, *, queue=None, timeout=300, delete_on_finish=False, tags=None)</code>","text":"<p>Register a task with a queue name and runnable instance.</p> <p>Parameters:</p> Name Type Description Default <code>runnable</code> <code>Runnable</code> <p>Langchain Runnable instance to process jobs</p> required <code>queue</code> <code>str | None</code> <p>Queue name to assign the task to</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Maximum time in seconds for a task to complete. If 0, messages will be popped instead of read.</p> <code>300</code> <code>delete_on_finish</code> <code>bool</code> <p>Whether to delete (True) or archive (False) jobs after processing</p> <code>False</code> <code>tags</code> <code>List[str] | None</code> <p>Optional list of tags to associate with the queue</p> <code>None</code> Source code in <code>src/aimq/worker.py</code> <pre><code>def assign(\n    self,\n    runnable: Runnable,\n    *,\n    queue: str | None = None,\n    timeout: int = 300,\n    delete_on_finish: bool = False,\n    tags: List[str] | None = None\n):\n    \"\"\"Register a task with a queue name and runnable instance.\n\n    Args:\n        runnable: Langchain Runnable instance to process jobs\n        queue: Queue name to assign the task to\n        timeout: Maximum time in seconds for a task to complete. If 0, messages will be popped instead of read.\n        delete_on_finish: Whether to delete (True) or archive (False) jobs after processing\n        tags: Optional list of tags to associate with the queue\n    \"\"\"\n\n    runnable.name = queue or runnable.name\n    if runnable.name is None:\n        raise ValueError(\"Queue name is required\")\n\n    self.queues[runnable.name] = Queue(\n        runnable=runnable,\n        timeout=timeout,\n        tags=tags or [],\n        delete_on_finish=delete_on_finish,\n        logger=self.logger,\n        worker_name=self.name\n    )\n    self.logger.info(f\"Registered task {runnable.name}\")\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.Worker.load","title":"<code>load(worker_path)</code>  <code>classmethod</code>","text":"<p>Load a worker instance from a Python file.</p> <p>Parameters:</p> Name Type Description Default <code>worker_path</code> <code>Path</code> <p>Path to the Python file containing the worker instance</p> required <p>Returns:</p> Type Description <code>Worker</code> <p>Worker instance exported as 'worker' from the module</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the module cannot be loaded</p> <code>AttributeError</code> <p>If the module does not export a 'worker' attribute</p> Source code in <code>src/aimq/worker.py</code> <pre><code>@classmethod\ndef load(cls, worker_path: Path) -&gt; \"Worker\":\n    \"\"\"Load a worker instance from a Python file.\n\n    Args:\n        worker_path: Path to the Python file containing the worker instance\n\n    Returns:\n        Worker instance exported as 'worker' from the module\n\n    Raises:\n        ImportError: If the module cannot be loaded\n        AttributeError: If the module does not export a 'worker' attribute\n    \"\"\"\n    module = load_module(worker_path)\n\n    if not hasattr(module, \"worker\"):\n        raise AttributeError(f\"Module {worker_path} does not export a 'worker' attribute\")\n\n    worker = module.worker\n    worker.logger.info(f\"Tasks loaded from file {worker_path}\")\n\n    return worker\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.Worker.log","title":"<code>log(block=True)</code>","text":"<p>Print log events from the logger.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>bool</code> <p>If True, block until events are available</p> <code>True</code> Source code in <code>src/aimq/worker.py</code> <pre><code>def log(self, block: bool = True):\n    \"\"\"Print log events from the logger.\n\n    Args:\n        block: If True, block until events are available\n    \"\"\"\n    self.logger.print(block=block, level=self.log_level)\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.Worker.send","title":"<code>send(queue, data, delay=None)</code>","text":"<p>Send data to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>str</code> <p>Name of the queue to send data to</p> required <code>data</code> <code>dict[str, Any]</code> <p>Data to send</p> required <code>delay</code> <code>int | None</code> <p>Optional delay in seconds before sending the data</p> <code>None</code> Source code in <code>src/aimq/worker.py</code> <pre><code>def send(self, queue: str, data: dict[str, Any], delay: int | None = None):\n    \"\"\"Send data to a queue.\n\n    Args:\n        queue: Name of the queue to send data to\n        data: Data to send\n        delay: Optional delay in seconds before sending the data\n    \"\"\"\n    return self.queues[queue].send(data, delay)\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.Worker.start","title":"<code>start(block=True)</code>","text":"<p>Start processing tasks in an endless loop.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>bool</code> <p>If True, block until events are available</p> <code>True</code> Source code in <code>src/aimq/worker.py</code> <pre><code>def start(self, block: bool = True):\n    \"\"\"Start processing tasks in an endless loop.\n\n    Args:\n        block: If True, block until events are available\n    \"\"\"\n    if self.thread and self.thread.is_alive():\n        return\n\n    self.is_running.set()\n    self.thread = WorkerThread(self.queues, self.logger, self.is_running, idle_wait=self.idle_wait)\n    self.thread.start()\n\n    if block:\n        self.log(block=block)\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.Worker.stop","title":"<code>stop()</code>","text":"<p>Stop processing tasks and clear job history.</p> Source code in <code>src/aimq/worker.py</code> <pre><code>def stop(self):\n    \"\"\"Stop processing tasks and clear job history.\"\"\"\n    if self.is_running.is_set():\n        self.is_running.clear()\n        if self.thread:\n            self.thread.join()\n            self.thread = None\n        self.logger.info(\"Worker stopped\")\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.Worker.task","title":"<code>task(*, queue=None, timeout=300, tags=None, delete_on_finish=False)</code>","text":"<p>Decorator to register a function that returns a Runnable with a queue.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>str | None</code> <p>Name of the queue to get jobs from</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Maximum time in seconds for a task to complete. If 0, messages will be popped instead of read</p> <code>300</code> <code>delete_on_finish</code> <code>bool</code> <p>Whether to delete (True) or archive (False) jobs after processing</p> <code>False</code> <code>tags</code> <code>List[str] | None</code> <p>Optional list of tags to associate with the queue</p> <code>None</code> Source code in <code>src/aimq/worker.py</code> <pre><code>def task(\n    self,\n    *,\n    queue: str | None = None,\n    timeout: int = 300,\n    tags: List[str] | None = None,\n    delete_on_finish: bool = False,\n):\n    \"\"\"Decorator to register a function that returns a Runnable with a queue.\n\n    Args:\n        queue: Name of the queue to get jobs from\n        timeout: Maximum time in seconds for a task to complete. If 0, messages will be popped instead of read\n        delete_on_finish: Whether to delete (True) or archive (False) jobs after processing\n        tags: Optional list of tags to associate with the queue\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            return func(*args, **kwargs)\n\n        self.assign(\n            RunnableLambda(func, name=(queue or func.__name__)),\n            timeout=timeout,\n            delete_on_finish=delete_on_finish,\n            tags=tags\n        )\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.Worker.work","title":"<code>work(queue)</code>","text":"<p>Process a job from a queue.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>str</code> <p>Name of the queue to process a job from</p> required Source code in <code>src/aimq/worker.py</code> <pre><code>def work(self, queue: str):\n    \"\"\"Process a job from a queue.\n\n    Args:\n        queue: Name of the queue to process a job from\n    \"\"\"\n    return self.queues[queue].work()\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.WorkerThread","title":"<code>WorkerThread(queues, logger, running, idle_wait=1.0)</code>","text":"<p>               Bases: <code>Thread</code></p> <p>A thread that processes jobs from multiple queues.</p> <p>Parameters:</p> Name Type Description Default <code>queues</code> <code>OrderedDict[str, Queue]</code> <p>Ordered dictionary of queue name to Queue instance mappings</p> required <code>logger</code> <code>Logger</code> <p>Logger instance for recording worker activities</p> required <code>running</code> <code>Event</code> <p>Threading event to control the worker's execution</p> required <code>idle_wait</code> <code>float</code> <p>Time in seconds to wait when no jobs are found</p> <code>1.0</code> <p>Attributes:</p> Name Type Description <code>queues</code> <p>The queues to process jobs from</p> <code>logger</code> <p>Logger instance</p> <code>running</code> <p>Threading event controlling execution</p> <code>idle_wait</code> <p>Sleep duration when idle</p> Source code in <code>src/aimq/worker.py</code> <pre><code>def __init__(self, queues: OrderedDict[str, Queue], logger: Logger, running: threading.Event, idle_wait: float = 1.0):\n    super().__init__()\n    self.queues = queues\n    self.logger = logger\n    self.running = running\n    self.idle_wait = idle_wait\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker.WorkerThread-functions","title":"Functions","text":""},{"location":"reference/aimq/worker/#aimq.worker.WorkerThread.run","title":"<code>run()</code>","text":"<p>Start the worker thread.</p> Source code in <code>src/aimq/worker.py</code> <pre><code>def run(self):\n    \"\"\"Start the worker thread.\"\"\"\n    self.logger.info(\"Worker thread started\")\n\n    while self.running.is_set():\n        try:\n            found_jobs = False\n            for queue in self.queues.values():\n                if not self.running.is_set():\n                    break\n\n                # work next job in queue\n                try:\n                    found_jobs = found_jobs or bool(queue.work())\n                except RuntimeError as e:\n                    self.logger.error(f\"Runtime error in queue {queue.name}\", {\"error\": str(e)})\n\n            if not found_jobs:\n                self.logger.debug(\"No jobs found, waiting...\")\n                time.sleep(self.idle_wait)\n\n        except Exception as e:\n            self.logger.critical(\"Worker thread encountered an unhandled error\", {\"error\": str(e)})\n            self.running.clear()\n</code></pre>"},{"location":"reference/aimq/worker/#aimq.worker-functions","title":"Functions","text":""},{"location":"reference/aimq/clients/","title":"aimq.clients","text":""},{"location":"reference/aimq/clients/#aimq.clients","title":"<code>aimq.clients</code>","text":""},{"location":"reference/aimq/clients/supabase/","title":"aimq.clients.supabase","text":""},{"location":"reference/aimq/clients/supabase/#aimq.clients.supabase","title":"<code>aimq.clients.supabase</code>","text":""},{"location":"reference/aimq/clients/supabase/#aimq.clients.supabase-classes","title":"Classes","text":""},{"location":"reference/aimq/clients/supabase/#aimq.clients.supabase.SupabaseClient","title":"<code>SupabaseClient()</code>","text":"<p>A wrapper class for Supabase operations.</p> <p>Initialize the Supabase client.</p> Source code in <code>src/aimq/clients/supabase.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the Supabase client.\"\"\"\n    self._client: Optional[Client] = None\n</code></pre>"},{"location":"reference/aimq/clients/supabase/#aimq.clients.supabase.SupabaseClient-attributes","title":"Attributes","text":""},{"location":"reference/aimq/clients/supabase/#aimq.clients.supabase.SupabaseClient.client","title":"<code>client</code>  <code>property</code>","text":"<p>Get or create the Supabase client.</p> <p>Returns:</p> Name Type Description <code>Client</code> <code>Client</code> <p>Configured Supabase client</p> <p>Raises:</p> Type Description <code>SupabaseError</code> <p>If Supabase is not properly configured</p>"},{"location":"reference/aimq/clients/supabase/#aimq.clients.supabase.SupabaseClient-functions","title":"Functions","text":""},{"location":"reference/aimq/clients/supabase/#aimq.clients.supabase.SupabaseError","title":"<code>SupabaseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Supabase-related errors.</p>"},{"location":"reference/aimq/commands/","title":"aimq.commands","text":""},{"location":"reference/aimq/commands/#aimq.commands","title":"<code>aimq.commands</code>","text":"<p>AIMQ command line interface.</p>"},{"location":"reference/aimq/commands/start/","title":"aimq.commands.start","text":""},{"location":"reference/aimq/commands/start/#aimq.commands.start","title":"<code>aimq.commands.start</code>","text":""},{"location":"reference/aimq/commands/start/#aimq.commands.start-classes","title":"Classes","text":""},{"location":"reference/aimq/commands/start/#aimq.commands.start-functions","title":"Functions","text":""},{"location":"reference/aimq/commands/start/#aimq.commands.start.start","title":"<code>start(worker_path=typer.Argument(None, help='Path to the Python file containing worker definitions'), log_level=typer.Option(LogLevel.INFO, '--log-level', '-l', help='Set the log level (debug, info, warning, error, critical)', case_sensitive=False), debug=typer.Option(False, '--debug', '-d', help='Enable debug logging (shortcut for --log-level debug)'))</code>","text":"<p>Start the AIMQ worker with the specified tasks.</p> Source code in <code>src/aimq/commands/start.py</code> <pre><code>@app.command()\ndef start(\n    worker_path: Optional[Path] = typer.Argument(\n        None,\n        help=\"Path to the Python file containing worker definitions\",\n    ),\n    log_level: LogLevel = typer.Option(\n        LogLevel.INFO,\n        \"--log-level\",\n        \"-l\",\n        help=\"Set the log level (debug, info, warning, error, critical)\",\n        case_sensitive=False,\n    ),\n    debug: bool = typer.Option(\n        False,\n        \"--debug\",\n        \"-d\",\n        help=\"Enable debug logging (shortcut for --log-level debug)\",\n    ),\n):\n    \"\"\"Start the AIMQ worker with the specified tasks.\"\"\"\n    if worker_path:\n        worker = Worker.load(worker_path)\n    else:\n        worker = Worker()\n\n    worker.log_level = LogLevel.DEBUG if debug else log_level\n\n    def signal_handler(signum, frame):\n        \"\"\"Handle shutdown signals gracefully.\"\"\"\n        print('')\n        worker.logger.info(\"Shutting down...\")\n        worker.log(block=False)\n        worker.stop()\n        worker.log(block=False)\n        sys.exit(0)\n\n    # Set up signal handlers\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n    try:\n        worker.start()\n    except Exception as e:\n        worker.logger.error(f\"Error: {e}\")\n        worker.log(block=False)\n        worker.stop()\n        worker.log(block=False)\n        sys.exit(1)\n</code></pre>"},{"location":"reference/aimq/providers/","title":"aimq.providers","text":""},{"location":"reference/aimq/providers/#aimq.providers","title":"<code>aimq.providers</code>","text":""},{"location":"reference/aimq/providers/#aimq.providers-classes","title":"Classes","text":""},{"location":"reference/aimq/providers/#aimq.providers.QueueNotFoundError","title":"<code>QueueNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to access a queue that does not exist.</p>"},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider","title":"<code>QueueProvider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for queue providers.</p>"},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider-functions","title":"Functions","text":""},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider.archive","title":"<code>archive(queue_name, job_or_id)</code>  <code>abstractmethod</code>","text":"<p>Archive a message in the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef archive(self, queue_name: str, job_or_id: int | Job) -&gt; bool:\n    \"\"\"Archive a message in the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider.delete","title":"<code>delete(queue_name, job_or_id)</code>  <code>abstractmethod</code>","text":"<p>Delete a message from the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef delete(self, queue_name: str, job_or_id: int | Job) -&gt; bool:\n    \"\"\"Delete a message from the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider.pop","title":"<code>pop(queue_name)</code>  <code>abstractmethod</code>","text":"<p>Pop a message from the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef pop(self, queue_name: str) -&gt; Job | None:\n    \"\"\"Pop a message from the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider.read","title":"<code>read(queue_name, timeout, count)</code>  <code>abstractmethod</code>","text":"<p>Read messages from the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef read(self, queue_name: str, timeout: int, count: int) -&gt; List[Job]:\n    \"\"\"Read messages from the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider.send","title":"<code>send(queue_name, data, delay=None)</code>  <code>abstractmethod</code>","text":"<p>Add a message to the queue.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The ID of the added message</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef send(self, queue_name: str, data: dict[str, Any], delay: int | None = None) -&gt; int:\n    \"\"\"Add a message to the queue.\n\n    Returns:\n        int: The ID of the added message\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/#aimq.providers.QueueProvider.send_batch","title":"<code>send_batch(queue_name, data_list, delay=None)</code>  <code>abstractmethod</code>","text":"<p>Add a batch of messages to the queue.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: The IDs of the added messages</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef send_batch(self, queue_name: str, data_list: list[dict[str, Any]], delay: int | None = None) -&gt; list[int]:\n    \"\"\"Add a batch of messages to the queue.\n\n    Returns:\n        list[int]: The IDs of the added messages\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/#aimq.providers.SupabaseQueueProvider","title":"<code>SupabaseQueueProvider</code>","text":"<p>               Bases: <code>QueueProvider</code></p> <p>Supabase implementation of QueueProvider.</p>"},{"location":"reference/aimq/providers/base/","title":"aimq.providers.base","text":""},{"location":"reference/aimq/providers/base/#aimq.providers.base","title":"<code>aimq.providers.base</code>","text":""},{"location":"reference/aimq/providers/base/#aimq.providers.base-classes","title":"Classes","text":""},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueNotFoundError","title":"<code>QueueNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to access a queue that does not exist.</p>"},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider","title":"<code>QueueProvider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for queue providers.</p>"},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider-functions","title":"Functions","text":""},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider.archive","title":"<code>archive(queue_name, job_or_id)</code>  <code>abstractmethod</code>","text":"<p>Archive a message in the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef archive(self, queue_name: str, job_or_id: int | Job) -&gt; bool:\n    \"\"\"Archive a message in the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider.delete","title":"<code>delete(queue_name, job_or_id)</code>  <code>abstractmethod</code>","text":"<p>Delete a message from the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef delete(self, queue_name: str, job_or_id: int | Job) -&gt; bool:\n    \"\"\"Delete a message from the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider.pop","title":"<code>pop(queue_name)</code>  <code>abstractmethod</code>","text":"<p>Pop a message from the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef pop(self, queue_name: str) -&gt; Job | None:\n    \"\"\"Pop a message from the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider.read","title":"<code>read(queue_name, timeout, count)</code>  <code>abstractmethod</code>","text":"<p>Read messages from the queue.</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef read(self, queue_name: str, timeout: int, count: int) -&gt; List[Job]:\n    \"\"\"Read messages from the queue.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider.send","title":"<code>send(queue_name, data, delay=None)</code>  <code>abstractmethod</code>","text":"<p>Add a message to the queue.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The ID of the added message</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef send(self, queue_name: str, data: dict[str, Any], delay: int | None = None) -&gt; int:\n    \"\"\"Add a message to the queue.\n\n    Returns:\n        int: The ID of the added message\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/base/#aimq.providers.base.QueueProvider.send_batch","title":"<code>send_batch(queue_name, data_list, delay=None)</code>  <code>abstractmethod</code>","text":"<p>Add a batch of messages to the queue.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: The IDs of the added messages</p> Source code in <code>src/aimq/providers/base.py</code> <pre><code>@abstractmethod\ndef send_batch(self, queue_name: str, data_list: list[dict[str, Any]], delay: int | None = None) -&gt; list[int]:\n    \"\"\"Add a batch of messages to the queue.\n\n    Returns:\n        list[int]: The IDs of the added messages\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/aimq/providers/supabase/","title":"aimq.providers.supabase","text":""},{"location":"reference/aimq/providers/supabase/#aimq.providers.supabase","title":"<code>aimq.providers.supabase</code>","text":""},{"location":"reference/aimq/providers/supabase/#aimq.providers.supabase-classes","title":"Classes","text":""},{"location":"reference/aimq/providers/supabase/#aimq.providers.supabase.SupabaseQueueProvider","title":"<code>SupabaseQueueProvider</code>","text":"<p>               Bases: <code>QueueProvider</code></p> <p>Supabase implementation of QueueProvider.</p>"},{"location":"reference/aimq/tools/","title":"aimq.tools","text":""},{"location":"reference/aimq/tools/#aimq.tools","title":"<code>aimq.tools</code>","text":""},{"location":"reference/aimq/tools/ocr/","title":"aimq.tools.ocr","text":""},{"location":"reference/aimq/tools/ocr/#aimq.tools.ocr","title":"<code>aimq.tools.ocr</code>","text":"<p>OCR tools package.</p>"},{"location":"reference/aimq/tools/ocr/#aimq.tools.ocr-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/ocr/#aimq.tools.ocr.ImageOCR","title":"<code>ImageOCR(**kwargs)</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for performing OCR on images.</p> <p>Initialize the OCR processor.</p> Source code in <code>src/aimq/tools/ocr/image_ocr.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the OCR processor.\"\"\"\n    super().__init__(**kwargs)\n    self.processor = OCRProcessor()\n</code></pre>"},{"location":"reference/aimq/tools/ocr/#aimq.tools.ocr.ImageOCR-functions","title":"Functions","text":""},{"location":"reference/aimq/tools/ocr/#aimq.tools.ocr.ImageOCRInput","title":"<code>ImageOCRInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for ImageOCR.</p>"},{"location":"reference/aimq/tools/ocr/image_ocr/","title":"aimq.tools.ocr.image_ocr","text":""},{"location":"reference/aimq/tools/ocr/image_ocr/#aimq.tools.ocr.image_ocr","title":"<code>aimq.tools.ocr.image_ocr</code>","text":"<p>Tool for performing OCR on images.</p>"},{"location":"reference/aimq/tools/ocr/image_ocr/#aimq.tools.ocr.image_ocr-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/ocr/image_ocr/#aimq.tools.ocr.image_ocr.ImageOCR","title":"<code>ImageOCR(**kwargs)</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for performing OCR on images.</p> <p>Initialize the OCR processor.</p> Source code in <code>src/aimq/tools/ocr/image_ocr.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the OCR processor.\"\"\"\n    super().__init__(**kwargs)\n    self.processor = OCRProcessor()\n</code></pre>"},{"location":"reference/aimq/tools/ocr/image_ocr/#aimq.tools.ocr.image_ocr.ImageOCR-functions","title":"Functions","text":""},{"location":"reference/aimq/tools/ocr/image_ocr/#aimq.tools.ocr.image_ocr.ImageOCRInput","title":"<code>ImageOCRInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for ImageOCR.</p>"},{"location":"reference/aimq/tools/ocr/processor/","title":"aimq.tools.ocr.processor","text":""},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor","title":"<code>aimq.tools.ocr.processor</code>","text":"<p>OCR module for text extraction and processing from images.</p> <p>This module provides functionality for extracting and processing text from images using the EasyOCR library. It includes utilities for handling text bounding boxes, merging overlapping detections, and creating debug visualizations.</p>"},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.OCRProcessor","title":"<code>OCRProcessor(languages=None)</code>","text":"<p>Processor for performing OCR on images using EasyOCR.</p> <p>This class provides a high-level interface for performing OCR on images. It handles initialization of the EasyOCR reader, image preprocessing, text detection, and optional debug visualization.</p> <p>Attributes:</p> Name Type Description <code>languages</code> <p>List of language codes for OCR</p> <code>_reader</code> <p>Lazy-loaded EasyOCR reader instance</p> <p>Initialize OCR processor with specified languages.</p> <p>Parameters:</p> Name Type Description Default <code>languages</code> <code>Optional[List[str]]</code> <p>List of language codes (default: ['en'])</p> <code>None</code> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def __init__(self, languages: Optional[List[str]] = None) -&gt; None:\n    \"\"\"Initialize OCR processor with specified languages.\n\n    Args:\n        languages: List of language codes (default: ['en'])\n    \"\"\"\n    self.languages = languages or ['en']\n    self._reader = None\n</code></pre>"},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.OCRProcessor-attributes","title":"Attributes","text":""},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.OCRProcessor.reader","title":"<code>reader</code>  <code>property</code>","text":"<p>Get or initialize the EasyOCR reader.</p> <p>Returns:</p> Type Description <code>Reader</code> <p>easyocr.Reader: Initialized EasyOCR reader instance</p>"},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.OCRProcessor-functions","title":"Functions","text":""},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.OCRProcessor.process_image","title":"<code>process_image(image, save_debug_image=False)</code>","text":"<p>Process an image and return OCR results.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Union[str, Path, Image, bytes]</code> <p>The image to process. Can be one of: - Path to image file (str or Path) - PIL Image object - Bytes of image data</p> required <code>save_debug_image</code> <code>bool</code> <p>If True, includes debug image in output</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: OCR results including: - processing_time: Time taken to process in seconds - text: Extracted text content - debug_image: Optional base64 encoded debug image - detections: List of text detections with coordinates</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If image format is invalid or unreadable</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def process_image(\n    self, \n    image: Union[str, Path, Image.Image, bytes], \n    save_debug_image: bool = False,\n) -&gt; Dict[str, Any]:\n    \"\"\"Process an image and return OCR results.\n\n    Args:\n        image: The image to process. Can be one of:\n            - Path to image file (str or Path)\n            - PIL Image object\n            - Bytes of image data\n        save_debug_image: If True, includes debug image in output\n\n    Returns:\n        Dict[str, Any]: OCR results including:\n            - processing_time: Time taken to process in seconds\n            - text: Extracted text content\n            - debug_image: Optional base64 encoded debug image\n            - detections: List of text detections with coordinates\n\n    Raises:\n        ValueError: If image format is invalid or unreadable\n    \"\"\"\n    start_time = time.time()\n\n    # Convert input to a format EasyOCR can process\n    if isinstance(image, (str, Path)):\n        image_path = str(image)\n        pil_image = Image.open(image_path)\n    elif isinstance(image, bytes):\n        image_stream = io.BytesIO(image)\n        pil_image = Image.open(image_stream)\n        image_path = None\n    elif isinstance(image, Image.Image):\n        pil_image = image\n        image_path = None\n    else:\n        raise ValueError(\"Image must be a file path, PIL Image, or bytes\")\n\n    # Convert PIL Image to numpy array for EasyOCR\n    if pil_image.mode != 'RGB':\n        pil_image = pil_image.convert('RGB')\n    np_image = np.array(pil_image)\n\n    # Read the image with optimized parameters\n    results = self.reader.readtext(\n        np_image,\n        paragraph=False,\n        min_size=20,\n        text_threshold=0.7,\n        link_threshold=0.4,\n        low_text=0.4,\n        width_ths=0.7,\n        height_ths=0.9,\n        ycenter_ths=0.9,\n    )\n\n    # Format initial results\n    detections = []\n    for result in results:\n        if len(result) == 2:\n            bbox, text = result\n            confidence = 1.0\n        else:\n            bbox, text, confidence = result\n\n        x1, y1 = int(bbox[0][0]), int(bbox[0][1])\n        x2, y2 = int(bbox[1][0]), int(bbox[1][1])\n        x3, y3 = int(bbox[2][0]), int(bbox[2][1])\n        x4, y4 = int(bbox[3][0]), int(bbox[3][1])\n\n        detections.append({\n            \"text\": str(text),\n            \"confidence\": float(round(float(confidence), 3)),\n            \"bounding_box\": {\n                \"x\": x1,\n                \"y\": y1,\n                \"width\": x2 - x1,\n                \"height\": y3 - y1\n            }\n        })\n\n    # Group the detections\n    grouped_detections = group_text_boxes(\n        detections,\n        width_growth=20,\n        height_growth=1\n    )\n\n    end_time = time.time()\n    output = {\n        \"processing_time\": float(round(end_time - start_time, 2)),\n        \"detections\": grouped_detections,\n        \"text\": \" \".join(d[\"text\"] for d in grouped_detections)\n    }\n\n    if save_debug_image:\n        debug_image = self._create_debug_image(pil_image, grouped_detections)\n        # Convert debug image to bytes\n        debug_bytes = io.BytesIO()\n        debug_image.save(debug_bytes, format='PNG')\n        output[\"debug_image\"] = debug_bytes.getvalue()\n\n    return output\n</code></pre>"},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor-functions","title":"Functions","text":""},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.boxes_overlap","title":"<code>boxes_overlap(box1, box2)</code>","text":"<p>Check if two boxes overlap at all.</p> <p>Parameters:</p> Name Type Description Default <code>box1</code> <code>Dict[str, int]</code> <p>Dictionary with x, y, width, height</p> required <code>box2</code> <code>Dict[str, int]</code> <p>Dictionary with x, y, width, height</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if boxes overlap</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def boxes_overlap(box1: Dict[str, int], box2: Dict[str, int]) -&gt; bool:\n    \"\"\"\n    Check if two boxes overlap at all.\n\n    Args:\n        box1: Dictionary with x, y, width, height\n        box2: Dictionary with x, y, width, height\n\n    Returns:\n        bool: True if boxes overlap\n    \"\"\"\n    h_overlap = (\n        box1['x'] &lt; box2['x'] + box2['width'] and\n        box2['x'] &lt; box1['x'] + box1['width']\n    )\n\n    v_overlap = (\n        box1['y'] &lt; box2['y'] + box2['height'] and\n        box2['y'] &lt; box1['y'] + box1['height']\n    )\n\n    return h_overlap and v_overlap\n</code></pre>"},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.group_text_boxes","title":"<code>group_text_boxes(detections, width_growth=0, height_growth=0)</code>","text":"<p>Group text boxes that are spatially related.</p> <p>This function groups text boxes that are spatially related, starting with overlapping boxes. It can optionally expand boxes horizontally and vertically before grouping to capture nearby text that may be related.</p> <p>Parameters:</p> Name Type Description Default <code>detections</code> <code>List[Dict[str, Any]]</code> <p>List of detection dictionaries containing text and bounding boxes</p> required <code>width_growth</code> <code>int</code> <p>Number of pixels to expand boxes horizontally</p> <code>0</code> <code>height_growth</code> <code>int</code> <p>Number of pixels to expand boxes vertically</p> <code>0</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of grouped text detections with merged bounding boxes</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def group_text_boxes(\n    detections: List[Dict[str, Any]], \n    width_growth: int = 0, \n    height_growth: int = 0\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Group text boxes that are spatially related.\n\n    This function groups text boxes that are spatially related, starting with\n    overlapping boxes. It can optionally expand boxes horizontally and vertically\n    before grouping to capture nearby text that may be related.\n\n    Args:\n        detections: List of detection dictionaries containing text and bounding boxes\n        width_growth: Number of pixels to expand boxes horizontally\n        height_growth: Number of pixels to expand boxes vertically\n\n    Returns:\n        List[Dict[str, Any]]: List of grouped text detections with merged bounding boxes\n    \"\"\"\n    if not detections:\n        return []\n\n    def grow_box(box: Dict[str, int]) -&gt; Dict[str, int]:\n        \"\"\"Helper to expand a box by the growth parameters\"\"\"\n        return {\n            'x': box['x'],\n            'y': box['y'],\n            'width': box['width'] + width_growth,\n            'height': box['height'] + height_growth\n        }\n\n    groups = [[det] for det in detections]\n\n    while True:\n        merged = False\n        new_groups = []\n        used = set()\n\n        for i, group1 in enumerate(groups):\n            if i in used:\n                continue\n\n            merged_group = group1.copy()\n            used.add(i)\n\n            box1 = grow_box(merge_boxes([det['bounding_box'] for det in merged_group]))\n\n            for j, group2 in enumerate(groups):\n                if j in used:\n                    continue\n\n                box2 = merge_boxes([det['bounding_box'] for det in group2])\n\n                if boxes_overlap(box1, box2):\n                    merged_group.extend(group2)\n                    used.add(j)\n                    box1 = grow_box(merge_boxes([det['bounding_box'] for det in merged_group]))\n                    merged = True\n\n            new_groups.append(merged_group)\n\n        if not merged:\n            break\n\n        groups = new_groups\n\n    return [{\n        \"text\": ' '.join(det['text'] for det in sorted(\n            group,\n            key=lambda d: (d['bounding_box']['y'], d['bounding_box']['x'])\n        )),\n        \"confidence\": float(round(\n            sum(det['confidence'] for det in group) / len(group),\n            3\n        )),\n        \"bounding_box\": merge_boxes([det['bounding_box'] for det in group])\n    } for group in groups]\n</code></pre>"},{"location":"reference/aimq/tools/ocr/processor/#aimq.tools.ocr.processor.merge_boxes","title":"<code>merge_boxes(boxes)</code>","text":"<p>Merge a list of bounding boxes into a single box that encompasses all of them.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>List[Dict[str, int]]</code> <p>List of dictionaries with x, y, width, height</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Optional[Dict[str, int]]</code> <p>Merged bounding box or None if input is empty</p> Source code in <code>src/aimq/tools/ocr/processor.py</code> <pre><code>def merge_boxes(boxes: List[Dict[str, int]]) -&gt; Optional[Dict[str, int]]:\n    \"\"\"\n    Merge a list of bounding boxes into a single box that encompasses all of them.\n\n    Args:\n        boxes: List of dictionaries with x, y, width, height\n\n    Returns:\n        dict: Merged bounding box or None if input is empty\n    \"\"\"\n    if not boxes:\n        return None\n\n    min_x = min(box['x'] for box in boxes)\n    min_y = min(box['y'] for box in boxes)\n    max_x = max(box['x'] + box['width'] for box in boxes)\n    max_y = max(box['y'] + box['height'] for box in boxes)\n\n    return {\n        'x': int(min_x),\n        'y': int(min_y),\n        'width': int(max_x - min_x),\n        'height': int(max_y - min_y)\n    }\n</code></pre>"},{"location":"reference/aimq/tools/pdf/","title":"aimq.tools.pdf","text":""},{"location":"reference/aimq/tools/pdf/#aimq.tools.pdf","title":"<code>aimq.tools.pdf</code>","text":"<p>PDF tools for processing and manipulating PDF files.</p>"},{"location":"reference/aimq/tools/pdf/#aimq.tools.pdf-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/pdf/#aimq.tools.pdf.PageSplitter","title":"<code>PageSplitter</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for splitting PDF into pages.</p>"},{"location":"reference/aimq/tools/pdf/#aimq.tools.pdf-functions","title":"Functions","text":""},{"location":"reference/aimq/tools/pdf/#aimq.tools.pdf.get_tools","title":"<code>get_tools()</code>","text":"<p>Get all PDF tools.</p> Source code in <code>src/aimq/tools/pdf/__init__.py</code> <pre><code>def get_tools() -&gt; List[BaseTool]:\n    \"\"\"Get all PDF tools.\"\"\"\n    tools: List[BaseTool] = [\n        PageSplitter(),\n    ]\n    return tools\n</code></pre>"},{"location":"reference/aimq/tools/pdf/page_splitter/","title":"aimq.tools.pdf.page_splitter","text":""},{"location":"reference/aimq/tools/pdf/page_splitter/#aimq.tools.pdf.page_splitter","title":"<code>aimq.tools.pdf.page_splitter</code>","text":"<p>Tool for splitting PDFs into individual pages.</p>"},{"location":"reference/aimq/tools/pdf/page_splitter/#aimq.tools.pdf.page_splitter-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/pdf/page_splitter/#aimq.tools.pdf.page_splitter.PageSplitter","title":"<code>PageSplitter</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for splitting PDF into pages.</p>"},{"location":"reference/aimq/tools/pdf/page_splitter/#aimq.tools.pdf.page_splitter.PageSplitterInput","title":"<code>PageSplitterInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for PageSplitter.</p>"},{"location":"reference/aimq/tools/supabase/","title":"aimq.tools.supabase","text":""},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase","title":"<code>aimq.tools.supabase</code>","text":"<p>Supabase tools for interacting with Supabase services.</p>"},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase.Enqueue","title":"<code>Enqueue</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for enqueueing jobs to Supabase Queue.</p>"},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase.ReadFile","title":"<code>ReadFile</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for reading files from Supabase Storage.</p>"},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase.ReadRecord","title":"<code>ReadRecord</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for reading records from Supabase.</p>"},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase.WriteFile","title":"<code>WriteFile</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for writing files to Supabase Storage.</p>"},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase.WriteRecord","title":"<code>WriteRecord</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for writing records to Supabase.</p>"},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase-functions","title":"Functions","text":""},{"location":"reference/aimq/tools/supabase/#aimq.tools.supabase.get_tools","title":"<code>get_tools()</code>","text":"<p>Get all Supabase tools.</p> Source code in <code>src/aimq/tools/supabase/__init__.py</code> <pre><code>def get_tools() -&gt; List[BaseTool]:\n    \"\"\"Get all Supabase tools.\"\"\"\n    tools: List[BaseTool] = [\n        ReadRecord(),\n        WriteRecord(),\n        ReadFile(),\n        WriteFile(),\n    ]\n    return tools\n</code></pre>"},{"location":"reference/aimq/tools/supabase/enqueue/","title":"aimq.tools.supabase.enqueue","text":""},{"location":"reference/aimq/tools/supabase/enqueue/#aimq.tools.supabase.enqueue","title":"<code>aimq.tools.supabase.enqueue</code>","text":"<p>Tool for enqueueing jobs to Supabase Queue.</p>"},{"location":"reference/aimq/tools/supabase/enqueue/#aimq.tools.supabase.enqueue-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/supabase/enqueue/#aimq.tools.supabase.enqueue.Enqueue","title":"<code>Enqueue</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for enqueueing jobs to Supabase Queue.</p>"},{"location":"reference/aimq/tools/supabase/enqueue/#aimq.tools.supabase.enqueue.EnqueueInput","title":"<code>EnqueueInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for Enqueue.</p>"},{"location":"reference/aimq/tools/supabase/read_file/","title":"aimq.tools.supabase.read_file","text":""},{"location":"reference/aimq/tools/supabase/read_file/#aimq.tools.supabase.read_file","title":"<code>aimq.tools.supabase.read_file</code>","text":"<p>Tool for reading files from Supabase Storage.</p>"},{"location":"reference/aimq/tools/supabase/read_file/#aimq.tools.supabase.read_file-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/supabase/read_file/#aimq.tools.supabase.read_file.ReadFile","title":"<code>ReadFile</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for reading files from Supabase Storage.</p>"},{"location":"reference/aimq/tools/supabase/read_file/#aimq.tools.supabase.read_file.ReadFileInput","title":"<code>ReadFileInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for ReadFile.</p>"},{"location":"reference/aimq/tools/supabase/read_record/","title":"aimq.tools.supabase.read_record","text":""},{"location":"reference/aimq/tools/supabase/read_record/#aimq.tools.supabase.read_record","title":"<code>aimq.tools.supabase.read_record</code>","text":"<p>Tool for reading records from Supabase.</p>"},{"location":"reference/aimq/tools/supabase/read_record/#aimq.tools.supabase.read_record-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/supabase/read_record/#aimq.tools.supabase.read_record.ReadRecord","title":"<code>ReadRecord</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for reading records from Supabase.</p>"},{"location":"reference/aimq/tools/supabase/read_record/#aimq.tools.supabase.read_record.ReadRecordInput","title":"<code>ReadRecordInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for ReadRecord.</p>"},{"location":"reference/aimq/tools/supabase/write_file/","title":"aimq.tools.supabase.write_file","text":""},{"location":"reference/aimq/tools/supabase/write_file/#aimq.tools.supabase.write_file","title":"<code>aimq.tools.supabase.write_file</code>","text":"<p>Tool for writing files to Supabase Storage.</p>"},{"location":"reference/aimq/tools/supabase/write_file/#aimq.tools.supabase.write_file-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/supabase/write_file/#aimq.tools.supabase.write_file.WriteFile","title":"<code>WriteFile</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for writing files to Supabase Storage.</p>"},{"location":"reference/aimq/tools/supabase/write_file/#aimq.tools.supabase.write_file.WriteFileInput","title":"<code>WriteFileInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for WriteFile.</p>"},{"location":"reference/aimq/tools/supabase/write_record/","title":"aimq.tools.supabase.write_record","text":""},{"location":"reference/aimq/tools/supabase/write_record/#aimq.tools.supabase.write_record","title":"<code>aimq.tools.supabase.write_record</code>","text":"<p>Tool for writing records to Supabase.</p>"},{"location":"reference/aimq/tools/supabase/write_record/#aimq.tools.supabase.write_record-classes","title":"Classes","text":""},{"location":"reference/aimq/tools/supabase/write_record/#aimq.tools.supabase.write_record.WriteRecord","title":"<code>WriteRecord</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Tool for writing records to Supabase.</p>"},{"location":"reference/aimq/tools/supabase/write_record/#aimq.tools.supabase.write_record.WriteRecordInput","title":"<code>WriteRecordInput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input for WriteRecord.</p>"},{"location":"user-guide/document-processing/","title":"Document Processing","text":"<p>This guide covers AIMQ's document processing capabilities.</p>"},{"location":"user-guide/document-processing/#supported-document-types","title":"Supported Document Types","text":"<p>AIMQ supports processing various document types:</p> <ul> <li>Images (JPG, PNG, TIFF, etc.)</li> <li>PDFs</li> <li>Text documents</li> <li>Scanned documents</li> </ul>"},{"location":"user-guide/document-processing/#processing-pipeline","title":"Processing Pipeline","text":""},{"location":"user-guide/document-processing/#1-document-upload","title":"1. Document Upload","text":"<pre><code>from aimq.attachment import Attachment\n\n# Create attachment from file\nattachment = Attachment.from_file(\"document.pdf\")\n\n# Or from bytes\nattachment = Attachment.from_bytes(file_bytes, \"application/pdf\")\n</code></pre>"},{"location":"user-guide/document-processing/#2-document-analysis","title":"2. Document Analysis","text":"<pre><code>from aimq.tools.pdf import PDFProcessor\nfrom aimq.tools.ocr import ImageOCR\n\n# Process PDF\npdf_processor = PDFProcessor()\npdf_result = pdf_processor.process(attachment)\n\n# Process image with OCR\nocr = ImageOCR()\nocr_result = ocr.process(attachment)\n</code></pre>"},{"location":"user-guide/document-processing/#3-result-processing","title":"3. Result Processing","text":"<pre><code># Extract text\ntext = result[\"text\"]\n\n# Get metadata\nmetadata = result[\"metadata\"]\n\n# Access debug information\ndebug_info = result[\"debug\"]\n</code></pre>"},{"location":"user-guide/document-processing/#processing-tools","title":"Processing Tools","text":""},{"location":"user-guide/document-processing/#ocr-processing","title":"OCR Processing","text":"<pre><code>from aimq.tools.ocr import ImageOCR\n\nocr = ImageOCR()\n\n# Basic processing\nresult = ocr.process(image_attachment)\n\n# With debug visualization\nresult = ocr.process(image_attachment, save_debug_image=True)\ndebug_image = result[\"debug_image\"]\n</code></pre>"},{"location":"user-guide/document-processing/#pdf-processing","title":"PDF Processing","text":"<pre><code>from aimq.tools.pdf import PDFProcessor\n\nprocessor = PDFProcessor()\n\n# Process entire PDF\nresult = processor.process(pdf_attachment)\n\n# Process specific pages\nresult = processor.process(pdf_attachment, pages=[1, 3, 5])\n</code></pre>"},{"location":"user-guide/document-processing/#integration-with-queue-processing","title":"Integration with Queue Processing","text":"<pre><code>from aimq import Worker\nfrom aimq.tools.ocr import ImageOCR\n\nworker = Worker()\nworker.register_queue(\"documents\")\nocr = ImageOCR()\n\n@worker.processor(\"documents\")\nasync def process_document(job):\n    attachment = job.data[\"attachment\"]\n\n    # Process based on file type\n    if attachment.is_image():\n        return ocr.process(attachment)\n    elif attachment.is_pdf():\n        return pdf_processor.process(attachment)\n    else:\n        raise ValueError(f\"Unsupported file type: {attachment.mime_type}\")\n</code></pre>"},{"location":"user-guide/document-processing/#best-practices","title":"Best Practices","text":"<ol> <li> <p>File Type Validation <pre><code>if not attachment.is_supported():\n    raise ValueError(f\"Unsupported file type: {attachment.mime_type}\")\n</code></pre></p> </li> <li> <p>Error Handling <pre><code>try:\n    result = processor.process(attachment)\nexcept ProcessingError as e:\n    logger.error(f\"Processing failed: {e}\")\n    raise\n</code></pre></p> </li> <li> <p>Resource Management <pre><code>with attachment.open() as file:\n    result = processor.process(file)\n</code></pre></p> </li> <li> <p>Debug Mode <pre><code># Enable debug mode for more information\nprocessor.enable_debug()\nresult = processor.process(attachment)\ndebug_info = result[\"debug\"]\n</code></pre></p> </li> </ol>"},{"location":"user-guide/ocr/","title":"OCR (Optical Character Recognition)","text":"<p>This guide covers AIMQ's OCR capabilities for extracting text from images.</p>"},{"location":"user-guide/ocr/#basic-usage","title":"Basic Usage","text":"<pre><code>from aimq.tools.ocr import ImageOCR\n\n# Initialize OCR\nocr = ImageOCR()\n\n# Process an image\nresult = ocr.process_image(\"image.jpg\")\nprint(result[\"text\"])\n</code></pre>"},{"location":"user-guide/ocr/#features","title":"Features","text":""},{"location":"user-guide/ocr/#multi-language-support","title":"Multi-language Support","text":"<pre><code># Initialize with multiple languages\nocr = ImageOCR(languages=[\"en\", \"es\", \"fr\"])\n\n# Process image\nresult = ocr.process_image(\"multilingual.jpg\")\n</code></pre>"},{"location":"user-guide/ocr/#debug-visualization","title":"Debug Visualization","text":"<pre><code># Process with debug visualization\nresult = ocr.process_image(\"document.jpg\", save_debug_image=True)\n\n# Access debug image\ndebug_image = result[\"debug_image\"]\n</code></pre>"},{"location":"user-guide/ocr/#text-regions","title":"Text Regions","text":"<pre><code># Get detailed text regions\nresult = ocr.process_image(\"document.jpg\")\nfor region in result[\"regions\"]:\n    print(f\"Text: {region['text']}\")\n    print(f\"Confidence: {region['confidence']}\")\n    print(f\"Position: {region['bbox']}\")\n</code></pre>"},{"location":"user-guide/ocr/#integration-examples","title":"Integration Examples","text":""},{"location":"user-guide/ocr/#queue-processing","title":"Queue Processing","text":"<pre><code>from aimq import Worker\nfrom aimq.tools.ocr import ImageOCR\n\nworker = Worker()\nocr = ImageOCR()\n\n@worker.task(queue=\"ocr\")\ndef process_image(data):\n    image_data = data[\"image\"]\n    return ocr.process_image(image_data)\n</code></pre>"},{"location":"user-guide/ocr/#batch-processing","title":"Batch Processing","text":"<pre><code>from aimq.tools.ocr import BatchImageOCR\n\n# Initialize batch processor\nbatch_ocr = BatchImageOCR()\n\n# Process multiple images\nimages = [\"image1.jpg\", \"image2.jpg\", \"image3.jpg\"]\nresults = batch_ocr.process_images(images)\n</code></pre>"},{"location":"user-guide/ocr/#pdf-ocr","title":"PDF OCR","text":"<pre><code>from aimq.tools.ocr import PDFImageOCR\n\n# Initialize PDF OCR processor\npdf_ocr = PDFImageOCR()\n\n# Process PDF pages\nresult = pdf_ocr.process_pdf(\"document.pdf\")\n</code></pre>"},{"location":"user-guide/ocr/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user-guide/ocr/#image-preprocessing","title":"Image Preprocessing","text":"<pre><code>from aimq.tools.ocr import ImagePreprocessor\n\n# Initialize preprocessor\npreprocessor = ImagePreprocessor()\n\n# Preprocess image\nprocessed_image = preprocessor.process(\n    image,\n    denoise=True,\n    deskew=True,\n    enhance_contrast=True\n)\n\n# Run OCR on processed image\nresult = ocr.process_image(processed_image)\n</code></pre>"},{"location":"user-guide/ocr/#parallel-processing","title":"Parallel Processing","text":"<pre><code>from aimq.tools.ocr import ParallelOCR\n\n# Initialize parallel processor\nparallel_ocr = ParallelOCR(num_workers=4)\n\n# Process images in parallel\nresults = parallel_ocr.process_images(images)\n</code></pre>"},{"location":"user-guide/ocr/#best-practices","title":"Best Practices","text":"<ol> <li>Image Quality</li> <li>Ensure good image resolution (at least 300 DPI)</li> <li>Use clear, well-lit images</li> <li> <p>Remove noise and artifacts</p> </li> <li> <p>Language Selection</p> </li> <li>Specify correct languages for better accuracy</li> <li> <p>Use multiple languages only when needed</p> </li> <li> <p>Performance</p> </li> <li>Use batch processing for multiple images</li> <li>Enable preprocessing for poor quality images</li> <li> <p>Use parallel processing for large workloads</p> </li> <li> <p>Error Handling <pre><code>try:\n    result = ocr.process_image(image)\nexcept OCRError as e:\n    logger.error(f\"OCR failed: {e}\")\n    # Handle error appropriately\n</code></pre></p> </li> </ol>"},{"location":"user-guide/overview/","title":"User Guide Overview","text":"<p>AIMQ is designed to make document processing with AI capabilities easy and efficient. This guide will help you understand the core concepts and features of AIMQ.</p>"},{"location":"user-guide/overview/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/overview/#workers-and-queues","title":"Workers and Queues","text":"<p>AIMQ uses a worker-queue pattern where: - Workers manage the processing of jobs - Queues store and distribute jobs to workers - Jobs represent units of work (like documents to process)</p>"},{"location":"user-guide/overview/#document-processing","title":"Document Processing","text":"<p>AIMQ supports various document types: - Images (JPG, PNG, etc.) - PDFs - Text documents</p>"},{"location":"user-guide/overview/#ai-integration","title":"AI Integration","text":"<p>AIMQ integrates with various AI tools and services: - OCR for text extraction - Language models for text processing - Custom AI model integration</p>"},{"location":"user-guide/overview/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Document Processing Pipeline</li> <li>Upload documents to Supabase storage</li> <li>Queue documents for processing</li> <li>Extract text and metadata</li> <li> <p>Store results</p> </li> <li> <p>Batch Processing</p> </li> <li>Process multiple documents in parallel</li> <li>Handle different document types</li> <li> <p>Aggregate results</p> </li> <li> <p>Real-time Processing</p> </li> <li>Process documents as they are uploaded</li> <li>Send notifications when processing is complete</li> <li>Stream results to clients</li> </ol>"},{"location":"user-guide/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Queue Processing</li> <li>Explore Document Processing</li> <li>Try out OCR capabilities</li> </ul>"},{"location":"user-guide/queue-processing/","title":"Queue Processing","text":"<p>This guide explains how to work with AIMQ's queue processing system.</p>"},{"location":"user-guide/queue-processing/#queue-basics","title":"Queue Basics","text":""},{"location":"user-guide/queue-processing/#creating-a-queue-and-task","title":"Creating a Queue and Task","text":"<pre><code>from aimq import Worker\n\nworker = Worker()\n\n@worker.task(queue=\"documents\")\ndef process_document(data):\n    # Process document based on type\n    if data.get(\"process_type\") == \"ocr\":\n        return process_ocr(data)\n    elif data.get(\"process_type\") == \"pdf\":\n        return process_pdf(data)\n</code></pre>"},{"location":"user-guide/queue-processing/#sending-jobs-to-a-queue","title":"Sending Jobs to a Queue","text":"<pre><code># Send a job directly\nworker.send(\"documents\", {\n    \"file_id\": \"123\",\n    \"process_type\": \"ocr\"\n})\n\n# Or using the queue directly\nqueue = worker.queues[\"documents\"]\nqueue.send({\n    \"file_id\": \"456\",\n    \"process_type\": \"pdf\"\n})\n</code></pre>"},{"location":"user-guide/queue-processing/#processing-jobs","title":"Processing Jobs","text":""},{"location":"user-guide/queue-processing/#basic-job-processing","title":"Basic Job Processing","text":"<pre><code>@worker.processor(\"documents\")\nasync def process_document(job):\n    # Access job data\n    file_id = job.data[\"file_id\"]\n    process_type = job.data[\"process_type\"]\n\n    # Process based on type\n    if process_type == \"ocr\":\n        return await process_ocr(file_id)\n    elif process_type == \"pdf\":\n        return await process_pdf(file_id)\n</code></pre>"},{"location":"user-guide/queue-processing/#error-handling","title":"Error Handling","text":"<pre><code>@worker.processor(\"documents\")\nasync def process_document(job):\n    try:\n        result = await process_file(job.data)\n        return {\"status\": \"success\", \"result\": result}\n    except Exception as e:\n        # Job will be retried\n        raise ProcessingError(f\"Failed to process: {str(e)}\")\n</code></pre>"},{"location":"user-guide/queue-processing/#advanced-features","title":"Advanced Features","text":""},{"location":"user-guide/queue-processing/#job-priority","title":"Job Priority","text":"<pre><code># Send high priority job\nqueue.send(data, priority=1)\n\n# Send low priority job\nqueue.send(data, priority=10)\n</code></pre>"},{"location":"user-guide/queue-processing/#delayed-processing","title":"Delayed Processing","text":"<pre><code># Process after 1 hour\nqueue.send(data, delay=3600)\n</code></pre>"},{"location":"user-guide/queue-processing/#batch-processing","title":"Batch Processing","text":"<pre><code>@worker.processor(\"documents\")\nasync def process_documents(jobs):\n    results = []\n    for job in jobs:\n        result = await process_document(job)\n        results.append(result)\n    return results\n\n# Enable batch processing\nworker.enable_batch_processing(\"documents\", batch_size=10)\n</code></pre>"},{"location":"user-guide/queue-processing/#monitoring","title":"Monitoring","text":""},{"location":"user-guide/queue-processing/#job-status","title":"Job Status","text":"<pre><code># Check job status\njob = queue.get_job(job_id)\nprint(f\"Job {job.id} status: {job.status}\")\n\n# Get queue stats\nstats = queue.get_stats()\nprint(f\"Pending jobs: {stats.pending}\")\nprint(f\"Processing jobs: {stats.processing}\")\n</code></pre>"},{"location":"user-guide/queue-processing/#logging","title":"Logging","text":"<p>```python</p>"},{"location":"user-guide/queue-processing/#enable-debug-logging","title":"Enable debug logging","text":"<p>worker.set_log_level(\"DEBUG\")</p>"},{"location":"user-guide/queue-processing/#print-logs","title":"Print logs","text":"<p>worker.print_logs()</p>"}]}